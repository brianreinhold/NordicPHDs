#include "nrf_log.h"
#include "nrf_log_ctrl.h"
#include "nrf_log_default_backends.h"
#include "nrf_soc.h"

#include "ble_types.h"
#include "ble_gatts.h"

#include "GhsControlStructs.h"
#include "nomenclature.h"
#include "configGhsEncoder.h"
#include "msmt_queue.h"
#include "handleSpecializations.h"

/**
 * We have put as much of the specialization configuration code in this file. The first method to
 * be invoked is the configureSpecializations. Here we create the groups and the measurements to
 * be included in the groups. We then create the data array for each of the groups. We no longer
 * need the structures that were used to create the data array and thus we free them. This happens
 * prior to any connection. Once connected, we call updateData* methods to enter measurement data
 * and other 'observational' information into the array.
 *
 * The next method to be called is generateAndAddStoredMsmt. This method is invoked by pressing the
 * DK button 4. It is also done prior to connection and only if we want to simulate stored data.
 * Fake data is generated by using the timer. Each specialization has its own structure which have the
 * data to be inserted into the data array once connections get going.
 *
 * Nothing will happen now until we press DK button 3 to start advertising. The first method to be called
 * in this file will be handleSpecializationsOnSetTime() and only if we support a settable time stamp.
 * This method updates the RTC clock and our current time structure. It also takes care of any date
 * time adjustments in the stored data if we have any.
 *
 * Next will be the sendStoredSpecializationMsmts if we have stored data. The stored structure is placed
 * into a queue. In the main loop, the stored structure is pulled from the queue and then the
 * encodeSpecializationMsmt is called. Now the send_data flag is set to true and back in the main 
 * loop the send_data method is called. The next stored data element will not be placed into the queue
 * until the previous one completes (all fragments sent and a record done sent to the gateway client).
 *
 * The same procedure happens once the live data is commanded. The difference is that we have a timer
 * that triggers very fast that calls generateLiveDataForSpecializations which does the same thing as
 * the generate stored data using the timestamp to make measurements. The structure is then queued and
 * the same thing as with the stored data happens. This will continue until the user presses DK button 2
 * to disconnect. 
 *
 * The Spirometer specializations does not support generation of stored data (to difficult to fake) and only
 * one set of preset values are sent live and that is it. The Glucose specialization supports no live data,
 * just stored as that is the typcial use case. That was just our choice. The other specializations support
 * both stored and live data, but one must press DK button 4 prior to starting advertising to create a stored
 * data entry...one entry for every button push. * 
 */
s_GhsTime *sGhsTime                             = NULL;
s_TimeInfo *sTimeInfo                           = NULL;
s_TimeInfoData *sTimeInfoData                   = NULL;
s_SystemInfo *systemInfo                        = NULL;     // We need to keep this for the BT_SIG option
unsigned short pairing                          = SUPPORT_PAIRING;        // Value of 1 indicates that pairing/bonding is required.
unsigned char batteryCharValue                  = 0x63;
unsigned short numberOfStoredMsmtGroups         = 0;
unsigned short initialNumberOfStoredMsmtGroups  = 0;
unsigned long long latestTimeStamp              = 0;
unsigned long msmt_id                           = 1;
unsigned long recordNumber                      = 0;

#if (USES_STORED_DATA == 1)
    s_MsmtData storedMsmts[NUMBER_OF_STORED_MSMTS];     // Maximum number of stored msmts NUMBER_OF_STORED_MSMTS you want to support.
                                                        // The s_MsmtData struct contains all the information that we will get from
                                                        // the sensor. It is specified in the handleSpecializations.h file and is
                                                        // different for each specialization. You can create whatever structure you
                                                        // need depending upon your use case, but you will need to modify the code
                                                        // in this file accordingly.
#endif
bool reportStatus = true;                           // used in BP for device status.
/*
 * The epoch defines our base value which does not change during the connection unless it is
 * changed by a PHG set time. The base value is 0 if a relative time otherwise we set it to
 * a factory default for UTC (which will be wrong) but it will be corrected on the first set 
 * time by the PHG. We add the current tick counter to this base epoch to report our current
 * time and time stamps.
 */
unsigned long long epoch                        = 0;
unsigned long long factor                       = 1000L; // milliseconds


/*
  LE SECURITY MODES
    The security requirements of a device, a service or a service request are
    expressed in terms of a security mode and security level. Each service or
    service request may have its own security requirement. The device may also
    have a security requirement. A physical connection between two devices shall
    operate in only one security mode.
    There are three LE security modes, LE security mode 1, LE security mode 2,
    and LE security mode 3.

  10.2.1 LE security mode 1
    LE security mode 1 has the following security levels:
    1. No security (No authentication and no encryption)
    2. Unauthenticated pairing with encryption
    3. Authenticated pairing with encryption
    4. Authenticated LE Secure Connections pairing with encryption using a 128-
    bit strength encryption key.

    For certain services that require LE security mode 1, levels 2 or 3, a device
    may enforce the use of LE Secure Connections pairing before those services
    can be used.
    A connection operating in LE security mode 1 level 2 shall also satisfy the
    security requirements for LE security mode 1 level 1.
    A connection operating in LE security mode 1 level 3 shall also satisfy the
    security requirements for LE security mode 1 level 2 or LE security mode 1
    level 1.
    A connection operating in LE security mode 1 level 3 shall also satisfy the
    security requirements for LE security mode 2.
    A connection operating in LE security mode 1 level 4 shall also satisfy the
    security requirements for LE security mode 1 level 3 or LE security mode 1
    level 2 or LE security mode 1 level 1.
    A connection operating in LE security mode 1 level 4 shall also satisfy the
    security requirements for LE security mode 2.

  10.2.2 LE security mode 2
    LE security mode 2 has two security levels:
    1. Unauthenticated pairing with data signing
    2. Authenticated pairing with data signing
    LE security mode 2 shall only be used for connection based data signing.

    Data signing as defined in Section 10.4 shall not be used when a connection is
    operating in LE security mode 1 level 2, LE security mode 1 level 3, or LE
    security mode 1 level 4.

    10.2.3 Mixed security modes requirements
        If there are requirements for both LE security mode 1 and LE security mode 2
        level 2 for a given physical link then LE security mode 1 level 3 shall be used.
        If there are requirements for both LE security mode 1 level 3 and LE security
        mode 2 for a given physical link then LE security mode 1 level 3 shall be used.
        If there are requirements for both LE security mode 1 level 2 and LE security
        mode 2 level 1 for a given physical link then LE security mode 1 level 2 shall be
        used.
        If there are requirements for both LE security mode 1 level 4 and any other
        security mode or level for a given physical link then LE security mode 1 level 4
        shall be used.

    10.2.4 Secure Connections Only mode
        A device may be in a Secure Connections Only mode. When in Secure
        Connections Only mode only security mode 1 level 4 shall be used except for
        services that only require security mode 1 level 1.
        The device shall only accept new outgoing and incoming service level
        connections for services that require Security Mode 1, Level 4 when the remote
        device supports LE Secure Connections and authenticated pairing is used.

  10.2.5 LE security mode 3
    LE security mode 3 has three security levels:
    1. No security (no authentication and no encryption)
    2. Use of unauthenticated Broadcast_Code
    3. Use of authenticated Broadcast_Code
    LE security mode 3 shall be used to broadcast a Broadcast Isochronous Group
    (BIG) in an Isochronous Broadcaster or receive a BIS in a Synchronized
    Receiver.
    A device operating in security mode 3 level 1 shall require that the isochronous
    data is unencrypted.
    A device that operates in LE security mode 3 level 2 shall require a
    Broadcast_Code to encrypt the data that is transmitted in a BIS. A device that
    operates in this mode shall also satisfy the security requirements for LE
    security mode 3 level 1.

    A device that operates in LE security mode 3 level 3 shall require a
    Broadcast_Code to encrypt the data that is transmitted in a BIS. A device that
    operates in this mode shall also satisfy the security requirements for LE
    security mode 3 level 2 and LE security mode 3 level 1. If the device has not
    received a Broadcast_Code using an authenticated method when the service
    requires Level 3 security, the device should indicate an appropriate error to the
    user (e.g., Insufficient Security for Broadcast_Code).

 */
unsigned char security_char[2] = {0x01, 0x02};
unsigned short security_char_length = 2;

// Needed just because we use the same board for different options with stored flash.
// When the namekey is different than that in flash, flash is not loaded
#if (BP_CUFF == 1)
    const char nameKey[10] = {'G', 'H', 'S', '_', 'B', 'P', ' ', ' ', ' ', ' '};
    unsigned char feature[18] = {FEATURE_HAS_DEVICE_SPECIALIZATIONS, 
              3,  0x04, 0x4A, 0x02, 0x00, 0x2A, 0x48, 0x02, 0x00, 0xF0, 0x55, 0x80, 0x00,
              1,  0x07, 0x10, 0x01};
    unsigned short feature_length = 18;
#endif
#if (PULSE_OX == 1)
    const char nameKey[10] = {'G', 'H', 'S', '_', 'P', 'O', 'X', 'M', ' ', ' '};
    unsigned char feature[18] = {FEATURE_HAS_DEVICE_SPECIALIZATIONS, 
              3,  0xB8, 0x4B, 0x02, 0x00, 0x1A, 0x48, 0x02, 0x00, 0x30, 0x4B, 0x02, 0x00,
              1,  0x04, 0x10, 0x01};
    unsigned short feature_length = 18;
#endif
#if (GLUCOSE == 1)
    const char nameKey[10] = {'G', 'H', 'S', '_', 'G', 'L', 'U', 'C', ' ', ' '};
    unsigned char feature[22] = {FEATURE_HAS_DEVICE_SPECIALIZATIONS, 
              4,  0x70, 0x72, 0x02, 0x00, 0x04, 0x72, 0x80, 0x00, 0xE4, 0x71, 0x80, 0x00,
                  0xE0, 0x71, 0x80, 0x00,
              1,  0x11, 0x10, 0x01};
    unsigned short feature_length = 22;
#endif
#if (HEART_RATE == 1)
    const char nameKey[10] = {'G', 'H', 'S', '_', 'H', 'R', ' ', ' ', ' ', ' '};
    const unsigned char feature[10] = {FEATURE_HAS_DEVICE_SPECIALIZATIONS, 
              1,  0x82, 0x41, 0x02, 0x00,
              1,  0x8D, 0x10, 0x01};
    unsigned short feature_length = 10;
#endif
#if (SPIROMETER == 1)
    const char nameKey[10] = {'G', 'H', 'S', '_', 'S', 'P', 'I', 'R', ' ', ' '};
    unsigned char feature[82] = {FEATURE_HAS_DEVICE_SPECIALIZATIONS, 
              4,  0x14, 0x78, 0x80, 0x00, 0x7E, 0x00, 0x81, 0x00, 0x40, 0xE1, 0x02, 0x00,  // MDC_DIAG_SESSION_SPIRO, MDC_HF_AGE, MDC_MASS_BODY_ACTUAL
                  0x44, 0xE1, 0x02, 0x00, 0x64, 0x78, 0x80, 0x00, 0x82, 0x78, 0x80, 0x00,  // MDC_LEN_BODY_ACTUAL, MDC_ETHNICITY, MDC_BIRTH_SEX
                  0x17, 0x78, 0x80, 0x00, 0xD4, 0x50, 0x02, 0x00, 0xD4, 0x50, 0x02, 0x00,  // MDC_DIAG_SUB_SESSION_SPIRO_MANEUVER_STANDING, MDC_FLOW_AWAY, 
                  0x0A, 0x54, 0x02, 0x00, 0x0B, 0x54, 0x02, 0x00, 0x00, 0xE2, 0x02, 0x00,  // MDC_VOL_AWAY_EXP_FORCED_1S, MDC_VOL_AWAY_EXP_FORCED_6S, MDC_VOL_AWAY_EXP_FORCED_CAPACITY
                  0x08, 0x54, 0x02, 0x00, 0x58, 0xE2, 0x02, 0x00, 0x35, 0x78, 0x80, 0x00,  // MDC_FLOW_AWAY_EXP_FORCED_PEAK, MDC_VOL_AWAY_EXP_FORCED_TIME, MDC_VOL_AWAY_FEV1_Z_SCORE
                  0x36, 0x78, 0x80, 0x00, 0x37, 0x78, 0x80, 0x00, 0x50, 0x78, 0x80, 0x00,  // MDC_VOL_AWAY_FEV1_LLN, MDC_VOL_AWAY_FEV1_PERCENT_PRED, MDC_SPIRO_FVC_ATS_QUAL
                  0x51, 0x78, 0x80, 0x00,                                                  // MDC_SPIRO_FEV1_ATS_QUAL
              1,  0x1D, 0x10, 0x01};
    unsigned short feature_length = 82;
#endif
#if (SCALE == 1)
    const char nameKey[10] = {'G', 'H', 'S', '_', 'S', 'C', 'A', 'L', ' ', ' '};
    unsigned char feature[18] = {FEATURE_HAS_DEVICE_SPECIALIZATIONS, 
              3,  0x40, 0xE1, 0x02, 0x00, 0x44, 0xE1, 0x02, 0x00, 0x50, 0xE1, 0x02, 0x00,  // MDC_MASS_BODY_ACTUAL, MDC_LEN_BODY_ACTUAL, MDC_RATIO_MASS_BODY_LEN_SQ
              1,  0x0F, 0x10, 0x01};
    unsigned short feature_length = 18;
#endif
#if (THERMOMETER == 1)
    const char nameKey[10] = {'G', 'H', 'S', '_', 'T', 'E', 'M', 'P', ' ', ' '};
    unsigned char feature[14] = {FEATURE_HAS_DEVICE_SPECIALIZATIONS, 
              2,  0x0C, 0xE0, 0x02, 0x00, 0x5C, 0xE0, 0x02, 0x00,  // MDC_TEMP_EAR, MDC_TEMP_ROOM
              1,  0x08, 0x10, 0x01};
    unsigned short feature_length = 14;
#endif

extern s_Queue *queue;

extern volatile s_global_send global_send;
extern nrf_mutex_t q_mutex;

void ble_disconnected_handler(void *);
unsigned long long getEpochFromBytes(unsigned char *bytes);
bool prepareMeasurements(s_MsmtGroupData *msmtGroupData, unsigned short recordNumber);

/*
 * Bt Addresses:
 *      AA:4D:E3:02:E1:02   BP Cuff
 *      AA:4D:E3:02:E1:01   Pulse Ox
 *      AA:4D:E3:02:E1:04   Glucose
 *      AA:4D:E3:01:E1:07   Heart Rate
 *      AA:4D:E3:02:E1:03   Spirometer
 *      AA:4D:E3:02:E1:06   Scale
 *      AA:4D:E3:02:E1:05   Thermometer
 */

/**
 * Here the specialization -specific variables are defined. Some of the more important are
 * the data array pointers, and the structure that will carry the variables that would normally
 * be updated from a sensor, for example in the BP there is the sys, dias, mean, and PR as well
 * as the time stamp and whether or not time stamps are used. We also specify the array of these
 * structures that are to hold stored data.
 * The other variables of interest are the '_index' variables. These are created by the library
 * when you add a measurement to a group. When you want to update a value of that measurement, this
 * index value is passed to the update method. The index value gives the position in the group
 * of the measurement, so it is just a value starting at 0 for the measurement first in the group
 * and increasing after. That index is used by the library to get a structure that has position
 * information for the updated variables in that measurement. For example, if you are updating the
 * pulse rate of the BP cuff, pr_index might be 1 (and bp_index is likely 0) and that gets the
 * internal msmtIndex[pr_index] struct. That struct contains index of the pulse rate in the entire
 * data array so the library can insert that value into the data array.
 * The application does not need to understand any of this. The library creates the pr_index and
 * the app only needs to use that value when updating the PR.
 */

#if (BP_CUFF == 1)
    unsigned short BLE_APPEARANCE = BLE_APPEARANCE_GENERIC_BLOOD_PRESSURE; // The appearance goies into the advertisement. It is
                                                                           // not necessary. These values are standardized by BT
                                                                           // SIG.
    static unsigned char bluetoothAddress[]         = {0x02, 0xE1, 0x02, 0xE3, 0x4D, 0xAA}; // Bluetooth address AA:4D:E3:02:E1:02
                                                                                            // in little endian. Every device needs that.
    static unsigned char systemId[]                 = {0x02, 0xE1, 0x02, 0xFF, 0xFE, 0xE3, 0x4D, 0xAA}; // This is the IEEE system id
                                                                                                        // We generate one from the
                                                                                                        // Bluetooth address. This value
                                                                                                        // is used in the SystemInfo which
                                                                                                        // also contains info like the
                                                                                                        // serial number.

    char *DEVICE_NAME                               = "GhsSig BP";                 // The device name. Used in the advertisement. Don't make
                                                                                // too long or there wont be enough space in the advertisement.
    unsigned short SPECIALIZATION                   = MDC_DEV_SPEC_PROFILE_BP;  // This is the MDC code for blood pressure. It will appear
                                                                                // in the service data field. Since the UUID of every GHS
                                                                                // is the same, in order to tell what kind of device it is
                                                                                // the service data field is used. This value is also sent
                                                                                // in the systemInfo (equivalent to the DIS information). It 
                                                                                // is very important to include the specialization code!
    static char *MODEL_NUMBER                       = "GHS-BP-234r";            // The System Info model number
    static char *MANUFACTURER_NAME                  = "GHS Blood Pressure";     // The System Info manufacturer name
    static char *SERIAL_NUMBER                      = "snX-4956";               // The System Info serial number
    static char *FIRMWARE_VERSION                   = "fw90.9";                 // The System Info firmware version
    static char *HARDWARE_VERSION                   = "hw5.7.61";               // The System Info hardware version
    static char *SOFTWARE_VERSION                   = "sw0.0.5";                // The System Info software version

    static char *UDI_LABEL                          = "";
    static char *UDI_DEV_ID                         = "";
    static char *UDI_ISSUER_OID                     = "";
    static char *UDI_AUTH_OID                       = "";

    static unsigned char regCertDataList[22]        = { 0, 2, 0, 0x12, 2, 1, 0, 8, 5, 0, 0, 1, 0, 2, 0x80, 7, 2, 2, 0, 2, 0x80, 0 };

    s_MsmtGroupData *msmtGroupBpData                = NULL; // This is a pointer to a struct that will contain the final data array to be sent
                                                            // to the client. The library will create and populate this structure for you and
                                                            // you will call a set of update methods to place the received sensor values into
                                                            // the final data array. The structure contains additional information as well, the
                                                            // most important being the locations in the data array for the updated measurement
                                                            // values.
    s_MsmtGroupData *msmtGroupOptimizedBpData       = NULL; // This structure would be the optimized version of the above data array. We do not
                                                            // use it in the BP example
    short bp_index                                  = -1;   // The bp_index is the placing (order) of the bp measurement in the data array. This value is
                                                            // is returned by the 'addGhsMsmtToGroup() method. If the bp measurement is the first
                                                            // measurement you add to the group, the value will be 0. If it is the second, the
                                                            // value will be 1. In this example we add it first. You will need this value when
                                                            // calling the update methods to enter new BP values into the data array. Do not change
                                                            // this value! Initialize it to -1 to indicate that it has not been defined yet.
    short pr_index                                  = -1;   // The pr_index is the placing of the pulse rate measurement in the data array. In our
                                                            // example, we place it second so the value would be 1. Do not change
                                                            // this value! Initialize it to -1 to indicate that it has not been used yet.
    short status_index                              = -1;   // The status_index is the placing of the status measurement in the data array. We place it
                                                            // third so its value would be 2. 
                                                            // Intermittent use. Status events are fairly common for some devices but they do not always
                                                            // occur. SO there are two options for devices that support intermittent status events.
                                                            // The first is to just send a value of all 0's to indicate that nothing of interest happened
                                                            // (usually means the measurement happened without problems so no status event is generally
                                                            // a good thing). The other option is to not send the status measurement at all unless it
                                                            // happens.
                                                            // In order to support the latter case (for efficiency) there is a method called 
                                                            // updateDataDropLastMsmt that when called will populate some of the parameters of
                                                            // the msmtGroupBpData struct such that the last measurement in the group is not sent. All
                                                            // the remaining header parameters are adjusted accordingly. There is a second method 
                                                            // updateDataRestoreLastMsmt that will reset the parameters such that the last measurement
                                                            // will be sent. We do that here. We create all three measurement types and add the status
                                                            // measurement LAST. Then we call the drop method. When status events are received from our
                                                            // fake sensor, we call the update method and update the status msmt with those values. We 
                                                            // call the drop method on the next measurement not to have status events.
#endif

#if (PULSE_OX == 1)
    unsigned short BLE_APPEARANCE = BLE_APPEARANCE_PULSE_OXIMETER_FINGERTIP;
    static unsigned char bluetoothAddress[]         = {0x01, 0xE1, 0x02, 0xE3, 0x4D, 0xAA}; // AA:4D:E3:02:E1:01 in little endian
    static unsigned char systemId[]                 = {0x01, 0xE1, 0x02, 0xFF, 0xFE, 0xE3, 0x4D, 0xAA};

    char *DEVICE_NAME                               = "GhsSig Pulse Ox";
    unsigned short SPECIALIZATION                   = MDC_DEV_SPEC_PROFILE_PULS_OXIM;
    static char *MODEL_NUMBER                       = "GHS-PO-234r";
    static char *MANUFACTURER_NAME                  = "GHS Pulse Oximetry";
    static char *SERIAL_NUMBER                      = "snX-4956";               // The System Info serial number
    static char *FIRMWARE_VERSION                   = "fw90.9";                 // The System Info firmware version
    static char *HARDWARE_VERSION                   = "hw5.7.61";               // The System Info hardware version
    static char *SOFTWARE_VERSION                   = "sw0.0.5";                // The System Info software version

    static char *UDI_LABEL                          = "";
    static char *UDI_DEV_ID                         = "";
    static char *UDI_ISSUER_OID                     = "";
    static char *UDI_AUTH_OID                       = "";
    unsigned char regCertDataList[22]               = { 0, 2, 0, 0x12, 2, 1, 0, 8, 5, 0, 0, 1, 0, 2, 0x80, 0x04, 2, 2, 0, 2, 0x80, 0 };

    s_MsmtGroupData *msmtGroupSpotData              = NULL;
    s_MsmtGroupData *msmtGroupContData              = NULL;
    s_MsmtGroupData *msmtGroupOptimizedContData     = NULL;
    short spo2_index                                = -1;
    short pr_index                                  = -1;
    short qual_index                                = -1;
    short spo2_cont_index                           = -1;
    short pr_cont_index                             = -1;
    short qual_cont_index                           = -1;
#endif
#if (GLUCOSE == 1)
    unsigned short BLE_APPEARANCE = BLE_APPEARANCE_GENERIC_GLUCOSE_METER;
    static unsigned char bluetoothAddress[]         = {0x04, 0xE1, 0x02, 0xE3, 0x4D, 0xAA}; // AA:4D:E3:02:E1:04 in little endian
    static unsigned char systemId[]                 = {0x04, 0xE1, 0x02, 0xFF, 0xFE, 0xE3, 0x4D, 0xAA};

    char *DEVICE_NAME                               = "GhsSig Glucose";
    unsigned short SPECIALIZATION                   = MDC_DEV_SPEC_PROFILE_GLUCOSE;
    static char *MODEL_NUMBER                       = "GHS-GLUC-234r";
    static char *MANUFACTURER_NAME                  = "GHS Diabetes Monitoring";
    static char *SERIAL_NUMBER                      = "snX-4956";               // The System Info serial number
    static char *FIRMWARE_VERSION                   = "fw90.9";                 // The System Info firmware version
    static char *HARDWARE_VERSION                   = "hw5.7.61";               // The System Info hardware version
    static char *SOFTWARE_VERSION                   = "sw0.0.5";                // The System Info software version

    static char *UDI_LABEL                          = "";
    static char *UDI_DEV_ID                         = "";
    static char *UDI_ISSUER_OID                     = "";
    static char *UDI_AUTH_OID                       = "";

    unsigned char regCertDataList[22]               = { 0, 2, 0, 0x12, 2, 1, 0, 8, 5, 0, 0, 1, 0, 2, 0x80, 0x11, 2, 2, 0, 2, 0x80, 0 };

    s_MsmtGroupData *msmtGroupGlucData              = NULL;
    short conc_index                                = -1;
    short meds_index                                = -1;
    short carbs_index                               = -1;
    short exer_index                                = -1;
#endif
#if (HEART_RATE == 1)
    unsigned short BLE_APPEARANCE = BLE_APPEARANCE_GENERIC_HEART_RATE_SENSOR;
    static unsigned char bluetoothAddress[]         = {0x07, 0xE1, 0x02, 0xE3, 0x4D, 0xAA}; // AA:4D:E3:02:F1:07 in little endian
    static unsigned char systemId[]                 = {0x07, 0xE1, 0x02, 0xFF, 0xFE, 0xE3, 0x4D, 0xAA};
    
    static unsigned char regCertDataList[22]        = { 0, 2, 0, 0x12, 2, 1, 0, 8, 6, 0, 0, 1, 0, 2, 0x80, 0x8D, 2, 2, 0, 2, 0x80, 0 };

    char *DEVICE_NAME                               = "GHS Heart Rate";
    unsigned short SPECIALIZATION                   = MDC_DEV_SUB_SPEC_PROFILE_HR;
    static char *MODEL_NUMBER                       = "GHS-HR-234r";
    static char *MANUFACTURER_NAME                  = "GHS Health Monitoring";
    static char *SERIAL_NUMBER                      = "snX-4444";               // The System Info serial number
    static char *FIRMWARE_VERSION                   = "fw10.9";                 // The System Info firmware version
    static char *HARDWARE_VERSION                   = "hw5.5.61";               // The System Info hardware version
    static char *SOFTWARE_VERSION                   = "sw3.0";                  // The System Info software version

    static char *UDI_LABEL                          = "";
    static char *UDI_DEV_ID                         = "";
    static char *UDI_ISSUER_OID                     = "";
    static char *UDI_AUTH_OID                       = "";
    s_MsmtGroupData *msmtGroupHrData                = NULL;
    short hr_index                                  = -1;
#endif
/**
 * It's hard to generate Spirometry data that makes even remote sense, especially the waveforms. So in this case we use data
 * from an actual maneuver and report that as live data only and its a one-shot deal. The time keeps invoking the live data
 * generator every 5 seconds in this case but once the sequence is done and the final ATS summary results are reported, no
 * more data is sent. Only one maneuver is done as well as it takes SO much space to store the waveforms.
 */
#if (SPIROMETER == 1)
unsigned char flowBytes[] = {
 0x09, 0x00, 0x54, 0x00, 0x8A, 0x01, 0xC9, 0x03, 0x77, 0x05, 0x54, 0x05, 0x7D, 0x04, 0x69, 0x04, 0xD2, 0x04, 0x1D, 0x05, 0x45, 0x05, 0x68, 0x05, 0x77, 0x05, 0x63, 0x05, 0x40, 0x05,
 0x31, 0x05, 0x31, 0x05, 0x36, 0x05, 0x4A, 0x05, 0x3B, 0x05, 0x22, 0x05, 0x2C, 0x05, 0x27, 0x05, 0xFA, 0x04, 0xC3, 0x04, 0xAF, 0x04, 0xBE, 0x04, 0xDC, 0x04, 0xF5, 0x04, 0xF5, 0x04, 0xB9, 0x04, 0x6E, 0x04,
 0x4B, 0x04, 0x64, 0x04, 0xA0, 0x04, 0xC3, 0x04, 0xB4, 0x04, 0xAF, 0x04, 0xB4, 0x04, 0xA0, 0x04, 0x82, 0x04, 0x8C, 0x04, 0xA5, 0x04, 0xB9, 0x04, 0xB9, 0x04, 0xA0, 0x04, 0x8C, 0x04, 0x73, 0x04, 0x46, 0x04,
 0x50, 0x04, 0xA0, 0x04, 0xD7, 0x04, 0xAF, 0x04, 0x55, 0x04, 0x3C, 0x04, 0x5F, 0x04, 0x64, 0x04, 0x50, 0x04, 0x5A, 0x04, 0x55, 0x04, 0x32, 0x04, 0x5F, 0x04, 0x9B, 0x04, 0x8C, 0x04, 0x41, 0x04, 0x28, 0x04,
 0x32, 0x04, 0x3C, 0x04, 0x69, 0x04, 0x82, 0x04, 0x5A, 0x04, 0x32, 0x04, 0x32, 0x04, 0x1E, 0x04, 0xE2, 0x03, 0xEC, 0x03, 0x1E, 0x04, 0xF1, 0x03, 0xC9, 0x03, 0x0A, 0x04, 0x41, 0x04, 0xF1, 0x03, 0x9C, 0x03,
 0xCE, 0x03, 0x00, 0x04, 0xBA, 0x03, 0x97, 0x03, 0xC9, 0x03, 0xBF, 0x03, 0x6A, 0x03, 0x7E, 0x03, 0xF1, 0x03, 0x19, 0x04, 0xD3, 0x03, 0xA1, 0x03, 0x83, 0x03, 0x60, 0x03, 0x88, 0x03, 0xCE, 0x03, 0xA1, 0x03,
 0x6A, 0x03, 0x79, 0x03, 0x92, 0x03, 0x79, 0x03, 0x6A, 0x03, 0x79, 0x03, 0x83, 0x03, 0x8D, 0x03, 0x92, 0x03, 0x6F, 0x03, 0x6F, 0x03, 0x88, 0x03, 0x7E, 0x03, 0x74, 0x03, 0x83, 0x03, 0x65, 0x03, 0x15, 0x03,
 0xFC, 0x02, 0x2E, 0x03, 0x5B, 0x03, 0x65, 0x03, 0x65, 0x03, 0x60, 0x03, 0x3D, 0x03, 0x2E, 0x03, 0x5B, 0x03, 0x79, 0x03, 0x60, 0x03, 0x1A, 0x03, 0x06, 0x03, 0x33, 0x03, 0x3D, 0x03, 0x29, 0x03, 0x3D, 0x03,
 0x24, 0x03, 0xF7, 0x02, 0x38, 0x03, 0x6A, 0x03, 0x15, 0x03, 0xD9, 0x02, 0xF7, 0x02, 0x10, 0x03, 0x29, 0x03, 0x29, 0x03, 0x01, 0x03, 0xCF, 0x02, 0xAC, 0x02, 0xCF, 0x02, 0x15, 0x03, 0x15, 0x03, 0xF2, 0x02,
 0xF2, 0x02, 0xE3, 0x02, 0xB6, 0x02, 0xCA, 0x02, 0xE3, 0x02, 0xC0, 0x02, 0xA7, 0x02, 0xB1, 0x02, 0xD9, 0x02, 0xED, 0x02, 0xDE, 0x02, 0xC0, 0x02, 0xB1, 0x02, 0xB6, 0x02, 0xB6, 0x02, 0xA2, 0x02, 0xB1, 0x02,
 0xC0, 0x02, 0xAC, 0x02, 0xB1, 0x02, 0xC5, 0x02, 0xAC, 0x02, 0xBB, 0x02, 0xE3, 0x02, 0xBB, 0x02, 0x7F, 0x02, 0x8E, 0x02, 0xC5, 0x02, 0xCF, 0x02, 0xAC, 0x02, 0x8E, 0x02, 0x93, 0x02, 0xA2, 0x02, 0x70, 0x02,
 0x61, 0x02, 0x8E, 0x02, 0x70, 0x02, 0x61, 0x02, 0x9D, 0x02, 0xA2, 0x02, 0x89, 0x02, 0x75, 0x02, 0x48, 0x02, 0x3E, 0x02, 0x5C, 0x02, 0x57, 0x02, 0x61, 0x02, 0x93, 0x02, 0x7F, 0x02, 0x2F, 0x02, 0x57, 0x02,
 0x89, 0x02, 0x48, 0x02, 0x6B, 0x02, 0xBB, 0x02, 0x75, 0x02, 0x84, 0x02, 0xD4, 0x02, 0x84, 0x02, 0x2A, 0x02, 0x3E, 0x02, 0x39, 0x02, 0x39, 0x02, 0x70, 0x02, 0x75, 0x02, 0x39, 0x02, 0x34, 0x02, 0x34, 0x02,
 0x20, 0x02, 0x11, 0x02, 0x16, 0x02, 0x34, 0x02, 0x52, 0x02, 0x61, 0x02, 0x6B, 0x02, 0x66, 0x02, 0x4D, 0x02, 0x16, 0x02, 0xEE, 0x01, 0xFD, 0x01, 0x11, 0x02, 0x16, 0x02, 0x39, 0x02, 0x2A, 0x02, 0xD5, 0x01,
 0xDA, 0x01, 0x1B, 0x02, 0x0C, 0x02, 0xFD, 0x01, 0x34, 0x02, 0x43, 0x02, 0x1B, 0x02, 0x0C, 0x02, 0x1B, 0x02, 0x1B, 0x02, 0x25, 0x02, 0x0C, 0x02, 0xF8, 0x01, 0xF3, 0x01, 0xE9, 0x01, 0xE9, 0x01, 0xF8, 0x01,
 0x0C, 0x02, 0x1B, 0x02, 0x07, 0x02, 0xF3, 0x01, 0xF3, 0x01, 0xDA, 0x01, 0xBC, 0x01, 0xE9, 0x01, 0xE9, 0x01, 0xD0, 0x01, 0xF8, 0x01, 0xF8, 0x01, 0xDF, 0x01, 0x2A, 0x02, 0x07, 0x02, 0xB2, 0x01, 0xFD, 0x01,
 0x20, 0x02, 0xE4, 0x01, 0x11, 0x02, 0x0C, 0x02, 0xC1, 0x01, 0xCB, 0x01, 0xCB, 0x01, 0xB2, 0x01, 0xEE, 0x01, 0xE9, 0x01, 0xB2, 0x01, 0xB2, 0x01, 0x94, 0x01, 0x9E, 0x01, 0xD0, 0x01, 0xC6, 0x01, 0xB7, 0x01,
 0xA8, 0x01, 0x9E, 0x01, 0xA8, 0x01, 0xB2, 0x01, 0x9E, 0x01, 0x94, 0x01, 0xB2, 0x01, 0xBC, 0x01, 0xC6, 0x01, 0xC6, 0x01, 0xA8, 0x01, 0xB7, 0x01, 0xC6, 0x01, 0xB7, 0x01, 0xAD, 0x01, 0x6C, 0x01, 0x67, 0x01,
 0xBC, 0x01, 0xB7, 0x01, 0xB7, 0x01, 0xD5, 0x01, 0x8F, 0x01, 0x85, 0x01, 0xE4, 0x01, 0xDA, 0x01, 0xB2, 0x01, 0x9E, 0x01, 0x94, 0x01, 0x9E, 0x01, 0x76, 0x01, 0x76, 0x01, 0xB2, 0x01, 0x8A, 0x01, 0x71, 0x01,
 0xAD, 0x01, 0x8A, 0x01, 0x62, 0x01, 0x71, 0x01, 0x76, 0x01, 0xA8, 0x01, 0x9E, 0x01, 0x5D, 0x01, 0x53, 0x01, 0x4E, 0x01, 0x49, 0x01, 0x8A, 0x01, 0x8A, 0x01, 0x67, 0x01, 0x71, 0x01, 0x62, 0x01, 0x5D, 0x01,
 0x99, 0x01, 0x8A, 0x01, 0x71, 0x01, 0x71, 0x01, 0x44, 0x01, 0x62, 0x01, 0x7B, 0x01, 0x85, 0x01, 0x5D, 0x01, 0x3A, 0x01, 0x76, 0x01, 0x71, 0x01, 0x35, 0x01, 0x53, 0x01, 0x3F, 0x01, 0x21, 0x01, 0x5D, 0x01,
 0x49, 0x01, 0x26, 0x01, 0x4E, 0x01, 0x53, 0x01, 0x4E, 0x01, 0x35, 0x01, 0x30, 0x01, 0x80, 0x01, 0x76, 0x01, 0x3F, 0x01, 0x30, 0x01, 0x53, 0x01, 0x58, 0x01, 0x44, 0x01, 0x30, 0x01, 0x21, 0x01, 0x35, 0x01,
 0x62, 0x01, 0x5D, 0x01, 0x3A, 0x01, 0x2B, 0x01, 0x1C, 0x01, 0x08, 0x01, 0xF9, 0x00, 0x03, 0x01, 0x26, 0x01, 0x35, 0x01, 0x30, 0x01, 0x26, 0x01, 0x30, 0x01, 0x3F, 0x01, 0x26, 0x01, 0x12, 0x01, 0x30, 0x01, 
 0x30, 0x01, 0x35, 0x01, 0x30, 0x01, 0x1C, 0x01, 0xF4, 0x00, 0xF9, 0x00, 0x12, 0x01, 0x17, 0x01, 0x26, 0x01, 0x26, 0x01, 0x17, 0x01, 0x0D, 0x01, 0xD6, 0x00, 0xD6, 0x00, 0x1C, 0x01, 0x35, 0x01, 0x49, 0x01, 
 0x4E, 0x01, 0x35, 0x01, 0x21, 0x01, 0xEA, 0x00, 0xE0, 0x00, 0x21, 0x01, 0x3A, 0x01, 0x3A, 0x01, 0x17, 0x01, 0x03, 0x01, 0xF9, 0x00, 0xEF, 0x00, 0xFE, 0x00, 0x0D, 0x01, 0x1C, 0x01, 0x12, 0x01, 0xD6, 0x00, 
 0xD1, 0x00, 0x0D, 0x01, 0x0D, 0x01, 0xE5, 0x00, 0xE5, 0x00, 0x0D, 0x01, 0x12, 0x01, 0x03, 0x01, 0x0D, 0x01, 0x03, 0x01, 0xD1, 0x00, 0xC2, 0x00, 0xBD, 0x00, 0xD6, 0x00, 0x17, 0x01, 0x12, 0x01, 0xF4, 0x00, 
 0xC7, 0x00, 0xD1, 0x00, 0x12, 0x01, 0xF4, 0x00, 0xDB, 0x00, 0xDB, 0x00, 0xD6, 0x00, 0xC7, 0x00, 0xE5, 0x00, 0xF9, 0x00, 0xEA, 0x00, 0xD6, 0x00, 0xEA, 0x00, 0x0D, 0x01, 0xF9, 0x00, 0xE5, 0x00, 0xE0, 0x00, 
 0xD6, 0x00, 0xC7, 0x00, 0xDB, 0x00, 0xE0, 0x00, 0xD1, 0x00, 0xDB, 0x00, 0xEA, 0x00, 0xC7, 0x00, 0xCC, 0x00, 0xD6, 0x00, 0xB8, 0x00, 0xC2, 0x00, 0xD6, 0x00, 0xEA, 0x00, 0xD1, 0x00, 0xBD, 0x00, 0xB8, 0x00, 
 0xB8, 0x00, 0xE0, 0x00, 0xCC, 0x00, 0xB8, 0x00, 0xDB, 0x00, 0xC2, 0x00, 0xA4, 0x00, 0xA9, 0x00, 0xAE, 0x00, 0xAE, 0x00, 0xD1, 0x00, 0xD6, 0x00, 0xC7, 0x00, 0xE0, 0x00, 0xC7, 0x00, 0xAE, 0x00, 0xDB, 0x00, 
 0xD1, 0x00, 0xBD, 0x00, 0xD1, 0x00, 0xBD, 0x00, 0xBD, 0x00, 0xE5, 0x00, 0xC2, 0x00, 0x9A, 0x00, 0x90, 0x00, 0xB8, 0x00, 0xDB, 0x00, 0xC2, 0x00, 0xAE, 0x00, 0x9F, 0x00, 0xB8, 0x00, 0xB8, 0x00, 0xA9, 0x00, 
 0xA9, 0x00, 0xB3, 0x00, 0xE5, 0x00, 0xD6, 0x00, 0xA9, 0x00, 0x86, 0x00, 0x9A, 0x00, 0xE0, 0x00, 0xE0, 0x00, 0xA9, 0x00, 0x81, 0x00, 0x6D, 0x00, 0x9A, 0x00, 0xEF, 0x00, 0xEA, 0x00, 0xAE, 0x00, 0x81, 0x00, 
 0x86, 0x00, 0x9A, 0x00, 0xC2, 0x00, 0xEF, 0x00, 0xCC, 0x00, 0x95, 0x00, 0x7C, 0x00, 0x77, 0x00, 0x7C, 0x00, 0x86, 0x00, 0xA4, 0x00, 0xB8, 0x00, 0xD6, 0x00, 0xD6, 0x00, 0xB3, 0x00, 0x95, 0x00, 0x77, 0x00, 
 0x68, 0x00, 0x86, 0x00, 0x8B, 0x00, 0x9A, 0x00, 0xA4, 0x00, 0x9F, 0x00, 0x90, 0x00, 0x8B, 0x00, 0x90, 0x00, 0xA4, 0x00, 0x9F, 0x00, 0x95, 0x00, 0x8B, 0x00, 0x90, 0x00, 0x8B, 0x00, 0x86, 0x00, 0x95, 0x00, 
 0x90, 0x00, 0x8B, 0x00, 0x95, 0x00, 0x9F, 0x00, 0x9A, 0x00, 0x90, 0x00, 0x8B, 0x00, 0x90, 0x00, 0x9F, 0x00, 0x9F, 0x00, 0x7C, 0x00, 0x54, 0x00, 0x54, 0x00, 0x63, 0x00, 0x77, 0x00, 0xA9, 0x00, 0xAE, 0x00, 
 0x9A, 0x00, 0x8B, 0x00, 0x90, 0x00, 0x8B, 0x00, 0x72, 0x00, 0x63, 0x00, 0x68, 0x00, 0x81, 0x00, 0x9A, 0x00, 0xAE, 0x00, 0xA4, 0x00, 0x9A, 0x00, 0x77, 0x00, 0x4F, 0x00, 0x40, 0x00, 0x6D, 0x00, 0x9F, 0x00, 
 0xA9, 0x00, 0x9A, 0x00, 0x86, 0x00, 0x63, 0x00, 0x54, 0x00, 0x7C, 0x00, 0x95, 0x00, 0x90, 0x00, 0x68, 0x00, 0x54, 0x00, 0x77, 0x00, 0x81, 0x00, 0x6D, 0x00, 0x4A, 0x00, 0x59, 0x00, 0x77, 0x00, 0x90, 0x00, 
 0x90, 0x00, 0x72, 0x00, 0x72, 0x00, 0x77, 0x00, 0x86, 0x00, 0x7C, 0x00, 0x5E, 0x00, 0x5E, 0x00, 0x77, 0x00, 0x90, 0x00, 0x7C, 0x00, 0x63, 0x00, 0x63, 0x00, 0x5E, 0x00, 0x4A, 0x00, 0x45, 0x00, 0x7C, 0x00, 
 0x95, 0x00, 0x86, 0x00, 0x68, 0x00, 0x4A, 0x00, 0x3B, 0x00, 0x59, 0x00, 0x8B, 0x00, 0xA9, 0x00, 0x86, 0x00, 0x5E, 0x00, 0x59, 0x00, 0x59, 0x00, 0x4F, 0x00, 0x63, 0x00, 0x72, 0x00, 0x68, 0x00, 0x63, 0x00, 
 0x5E, 0x00, 0x40, 0x00, 0x36, 0x00, 0x59, 0x00, 0x6D, 0x00, 0x72, 0x00, 0x90, 0x00, 0x8B, 0x00, 0x68, 0x00, 0x4A, 0x00, 0x3B, 0x00, 0x40, 0x00, 0x72, 0x00, 0x81, 0x00, 0x77, 0x00, 0x81, 0x00, 0x68, 0x00, 
 0x54, 0x00, 0x4F, 0x00, 0x45, 0x00, 0x4A, 0x00, 0x77, 0x00, 0x86, 0x00, 0x63, 0x00, 0x31, 0x00, 0x2C, 0x00, 0x59, 0x00, 0x6D, 0x00, 0x59, 0x00, 0x36, 0x00, 0x4A, 0x00, 0x77, 0x00, 0x81, 0x00, 0x72, 0x00, 
 0x4F, 0x00, 0x40, 0x00, 0x59, 0x00, 0x63, 0x00, 0x4F, 0x00, 0x36, 0x00, 0x54, 0x00, 0x7C, 0x00, 0x81, 0x00, 0x63, 0x00, 0x3B, 0x00, 0x22, 0x00, 0x13, 0x00, 0x36, 0x00, 0x7C, 0x00, 0x90, 0x00, 0x68, 0x00, 
 0x31, 0x00, 0x36, 0x00, 0x40, 0x00, 0x45, 0x00, 0x3B, 0x00, 0x4F, 0x00, 0x68, 0x00, 0x6D, 0x00, 0x6D, 0x00, 0x5E, 0x00, 0x45, 0x00, 0x31, 0x00, 0x40, 0x00, 0x4F, 0x00, 0x45, 0x00, 0x31, 0x00, 0x40, 0x00, 
 0x4F, 0x00, 0x4F, 0x00, 0x45, 0x00, 0x5E, 0x00, 0x6D, 0x00, 0x59, 0x00, 0x31, 0x00, 0x18, 0x00, 0x18, 0x00, 0x45, 0x00, 0x63, 0x00, 0x5E, 0x00, 0x45, 0x00, 0x54, 0x00, 0x63, 0x00, 0x5E, 0x00, 0x40, 0x00, 
 0x40, 0x00, 0x45, 0x00, 0x3B, 0x00, 0x31, 0x00, 0x45, 0x00, 0x59, 0x00, 0x54, 0x00, 0x36, 0x00, 0x2C, 0x00, 0x4F, 0x00, 0x63, 0x00, 0x54, 0x00, 0x36, 0x00, 0x36, 0x00, 0x40, 0x00, 0x40, 0x00, 0x36, 0x00, 
 0x4A, 0x00, 0x59, 0x00, 0x4A, 0x00, 0x31, 0x00, 0x18, 0x00, 0x18, 0x00, 0x36, 0x00, 0x6D, 0x00, 0x77, 0x00, 0x59, 0x00, 0x27, 0x00, 0x13, 0x00, 0x22, 0x00, 0x36, 0x00, 0x3B, 0x00, 0x45, 0x00, 0x6D, 0x00, 
 0x72, 0x00, 0x59, 0x00, 0x27, 0x00, 0x1D, 0x00, 0x31, 0x00, 0x45, 0x00, 0x40, 0x00, 0x22, 0x00, 0x1D, 0x00, 0x3B, 0x00, 0x59, 0x00, 0x54, 0x00, 0x31, 0x00, 0x22, 0x00, 0x45, 0x00, 0x59, 0x00, 0x4A, 0x00, 
 0x27, 0x00, 0x13, 0x00, 0x22, 0x00, 0x31, 0x00, 0x31, 0x00, 0x27, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x31, 0x00, 0x68, 0x00, 0x7C, 0x00, 0x63, 0x00, 0x31, 0x00, 0x18, 0x00, 0x2C, 0x00, 0x3B, 0x00, 
 0x36, 0x00, 0x22, 0x00, 0x13, 0x00, 0x18, 0x00, 0x3B, 0x00, 0x54, 0x00, 0x4A, 0x00, 0x36, 0x00, 0x31, 0x00, 0x59, 0x00, 0x68, 0x00, 0x4F, 0x00, 0x27, 0x00, 0x04, 0x00, 0x04, 0x00, 0x1D, 0x00, 0x36, 0x00, 
 0x3B, 0x00, 0x2C, 0x00, 0x1D, 0x00, 0x22, 0x00, 0x54, 0x00, 0x6D, 0x00, 0x59, 0x00, 0x31, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x09, 0x00, 0x13, 0x00, 0x27, 0x00, 0x4A, 0x00, 0x54, 0x00, 0x3B, 0x00, 0x18, 0x00, 
 0x09, 0x00, 0x09, 0x00, 0x18, 0x00, 0x3B, 0x00, 0x4F, 0x00, 0x45, 0x00, 0x2C, 0x00, 0x1D, 0x00, 0x22, 0x00, 0x4F, 0x00, 0x63, 0x00, 0x4F, 0x00, 0x27, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x22, 0x00, 
 0x31, 0x00, 0x2C, 0x00, 0x18, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x1D, 0x00, 0x54, 0x00, 0x77, 0x00, 0x59, 0x00, 0x27, 0x00, 0x04, 0x00, 0x00, 0x00, 0x13, 0x00, 0x3B, 0x00, 0x45, 0x00, 0x36, 0x00, 0x18, 0x00, 
 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x0E, 0x00, 0x31, 0x00, 0x40, 0x00, 0x3B, 0x00, 0x27, 0x00, 0x18, 0x00, 0x09, 0x00, 0x09, 0x00, 0x13, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x27, 0x00, 0x54, 0x00, 0x68, 0x00, 
 0x4F, 0x00, 0x1D, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x18, 0x00, 0x2C, 0x00, 0x3B, 0x00, 0x2C, 0x00, 0x1D, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x1D, 0x00, 0x4F, 0x00, 0x6D, 0x00, 0x59, 0x00, 
 0x31, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x04, 0x00, 0x13, 0x00, 0x31, 0x00, 0x45, 0x00, 0x36, 0x00, 0x18, 0x00, 0x09, 0x00, 0x09, 0x00, 0x0E, 0x00, 0x13, 0x00, 0x18, 0x00, 0x31, 0x00, 0x45, 0x00, 0x36, 0x00, 
 0x1D, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x0E, 0x00, 0x1D, 0x00, 0x4F, 0x00, 0x63, 0x00, 0x4F, 0x00, 0x1D, 0x00, 0xFC, 0xFF, 0xF7, 0xFF, 0xFC, 0xFF, 0x00, 0x00, 0x09, 0x00, 0x0E, 0x00, 0x22, 0x00, 
 0x31, 0x00, 0x2C, 0x00, 0x1D, 0x00, 0x13, 0x00, 0x13, 0x00, 0x0E, 0x00, 0x09, 0x00, 0x09, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x09, 0x00, 0x18, 0x00, 0x40, 0x00, 0x5E, 0x00, 0x4F, 0x00, 
 0x27, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x09, 0x00, 0x09, 0x00, 0x18, 0x00, 0x2C, 0x00, 0x31, 0x00, 0x2C, 0x00, 0x18, 0x00, 0x04, 0x00, 0x04, 0x00, 0x0E, 0x00, 0x13, 0x00, 0x13, 0x00, 0x0E, 0x00, 
 0x0E, 0x00, 0x27, 0x00, 0x3B, 0x00, 0x2C, 0x00, 0x18, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x13, 0x00, 0x13, 0x00, 0x0E, 0x00, 0x09, 0x00, 0x13, 0x00, 0x40, 0x00, 0x63, 0x00, 0x4F, 0x00, 0x1D, 0x00, 
 0xFC, 0xFF, 0xF7, 0xFF, 0x04, 0x00, 0x0E, 0x00, 0x13, 0x00, 0x09, 0x00, 0x00, 0x00, 0x09, 0x00, 0x22, 0x00, 0x31, 0x00, 0x2C, 0x00, 0x18, 0x00, 0x09, 0x00, 0x00, 0x00, 0x04, 0x00, 0x09, 0x00};

    unsigned short fev1Val = 1137;
    unsigned short fev6Val = 3117;
    unsigned short fvcVal  = 3393;
    unsigned short pefVal  = 1450;
    unsigned short fetVal  = 10000;
    short fev1z_val = -1500;   // Z score * 1000
    short fev1_lln_val = 2681; // LLN * 1000, 
    short fev1_percent_pred_val = 324;  // % predicted * 10
    unsigned long fvcAtsGradeVal = MDC_SPIRO_AST_QUAL_D;
    unsigned long fev1AtsGradeVal = MDC_SPIRO_AST_QUAL_D;

    #define AGE 71
    #define HEIGHT 1829
    #define WEIGHT 9072
    #define NO_OF_SAMPLES 500
    #define SAMPLE_SIZE 2
    unsigned short BLE_APPEARANCE                   = BLE_APPEARANCE_UNKNOWN;
    static unsigned char bluetoothAddress[]         = {0x03, 0xE1, 0x02, 0xE3, 0x4D, 0xAA}; // AA:4D:E3:02:E1:03 in little endian
    static unsigned char systemId[]                 = {0x03, 0xE1, 0x02, 0xFF, 0xFE, 0xE3, 0x4D, 0xAA};

    char *DEVICE_NAME                               = "GHS Spirometer";
    unsigned short SPECIALIZATION                   = MDC_DEV_SPEC_PROFILE_SPIRO;
    static char *MODEL_NUMBER                       = "GHS-SPIRO-234r";
    static char *MANUFACTURER_NAME                  = "GHS Spirometry";
    static char *SERIAL_NUMBER                      = "snX-4956";               // The System Info serial number
    static char *FIRMWARE_VERSION                   = "fw90.9";                 // The System Info firmware version
    static char *HARDWARE_VERSION                   = "hw5.7.61";               // The System Info hardware version
    static char *SOFTWARE_VERSION                   = "sw0.0.5";                // The System Info software version

    static char *UDI_LABEL                          = "udi label";
    static char *UDI_DEV_ID                         = "udi device identifier";
    static char *UDI_ISSUER_OID                     = "1.2.3.4.5.6.777";
    static char *UDI_AUTH_OID                       = "2.16.840.1.113883.3.24";
    
    unsigned char regCertDataList[22]               = { 0, 2, 0, 0x12, 2, 1, 0, 8, 5, 0, 0, 1, 0, 2, 0x80, 0x1D, 2, 2, 0, 2, 0x80, 0 };

    s_MsmtGroupData *msmtGroupSpiroSessionData      = NULL;
    s_MsmtGroupData *msmtGroupSpiroSettingsData     = NULL;
    s_MsmtGroupData *msmtGroupSpiroSubSessionData   = NULL;
    s_MsmtGroupData *msmtGroupSpiroStreamData       = NULL;
    s_MsmtGroupData *msmtGroupSpiroManeuvData       = NULL;
    s_MsmtGroupData *msmtGroupSpiroSummaryData      = NULL;
    s_MsmtGroupData *msmtGroupSpiroSessionEndData   = NULL;


    //unsigned short refs[1];
    unsigned long session_id;
    unsigned long sub_session_id;
    unsigned long fvc_ids[3];   // For msmts that are used in the final summary
    int fvc_id_index = 0;
    unsigned long fev1_ids[3];
    int fev1_id_index = 0;
    unsigned long settings_id[5];

    unsigned short spiro_sequence = 0;      // First dump settings, then stream, then maneuver, then summary

    // Spiro base variables
    short fev05_index                               = -1;
    short fev075_index                              = -1;
    short fev1_index                                = -1;
    short fev3_index                                = -1;
    short fev6_index                                = -1;
    short fvc_index                                 = -1;
    short pef_index                                 = -1;
    short fef25_index                               = -1;
    short fef50_index                               = -1;
    short fef75_index                               = -1;
    short fef25_75_index                            = -1;
    short fet_index                                 = -1;
    short tpef_index                                = -1;
    short extrap_index                              = -1;
    short temp_index                                = -1;
    short humid_index                               = -1;
    short airPress_index                            = -1;
    short fev1z_index                               = -1;
    short fev1_lln_index                            = -1;
    short fev1_percent_pred_index                   = -1;
    short fvcz_index                                = -1;
    short fvc_lln_index                             = -1;
    short fvc_percent_pred_index                    = -1;
    short fev1AtsGrade_index                        = -1;
    short fvcAtsGrade_index                         = -1;

    // Spiro settings variables
    short age_index                                 = -1;
    short weight_index                              = -1;
    short height_index                              = -1;
    short sex_index                                 = -1;
    short ethnicity_index                           = -1;
    // Spiro session variables
    short session_index                             = -1;
    short sub_session_index                         = -1;
    short session_end_index                         = -1;

    // Spiro streaming variables
    short flow_index                                = -1;
    short volume_index                              = -1;

#endif
#if (SCALE == 1)
    #define HEIGHT 1727         // 172.7 cm for setting (height in cm * 10)
    unsigned short BLE_APPEARANCE = BLE_APPEARANCE_GENERIC_WEIGHT_SCALE;
    static unsigned char bluetoothAddress[]         = {0x06, 0xE1, 0x02, 0xE3, 0x4D, 0xAA}; // AA:4D:E3:02:E1:06 in little endian
    static unsigned char systemId[]                 = {0x06, 0xE1, 0x02, 0xFF, 0xFE, 0xE3, 0x4D, 0xAA};

    char *DEVICE_NAME                               = "GHSSig Scale";  // Samsung refuses to connect if name is too short. This is too short. 'Ghs Weigh Scale' is okay
    unsigned short SPECIALIZATION                   = MDC_DEV_SPEC_PROFILE_SCALE;
    static char *MODEL_NUMBER                       = "GHS-Scale-234r";
    static char *MANUFACTURER_NAME                  = "GHS Scale Designers";
    static char *SERIAL_NUMBER                      = "snX-4956";               // The System Info serial number
    static char *FIRMWARE_VERSION                   = "fw90.9";                 // The System Info firmware version
    static char *HARDWARE_VERSION                   = "hw5.7.61";               // The System Info hardware version
    static char *SOFTWARE_VERSION                   = "sw0.0.5";                // The System Info software version

    static char *UDI_LABEL                          = "";
    static char *UDI_DEV_ID                         = "";
    static char *UDI_ISSUER_OID                     = "";
    static char *UDI_AUTH_OID                       = "";
    unsigned char regCertDataList[22]               = { 0, 2, 0, 0x12, 2, 1, 0, 8, 5, 0, 0, 1, 0, 2, 0x80, 0x0F, 2, 2, 0, 2, 0x80, 0 };

    s_MsmtGroupData *settingsGroupData              = NULL;
    s_MsmtGroupData *msmtGroupScaleData             = NULL;
    s_MsmtGroupData *msmtGroupOptimizedScaleData    = NULL;
    unsigned short height_ref                       = 0;
    short mass_index                                = -1;
    short height_index                              = -1;
    short bmi_index                                 = -1;
    unsigned short scale_sequence                   = 0;
#endif
#if (THERMOMETER == 1)
    unsigned short BLE_APPEARANCE = BLE_APPEARANCE_THERMOMETER_EAR;
    static unsigned char bluetoothAddress[]         = {0x05, 0xE1, 0x02, 0xE3, 0x4D, 0xAA}; // AA:4D:E3:02:E1:05 in little endian
    static unsigned char systemId[]                 = {0x05, 0xE1, 0x02, 0xFF, 0xFE, 0xE3, 0x4D, 0xAA};

    char *DEVICE_NAME                               = "GhsSig Ear Therm";
    unsigned short SPECIALIZATION                   = MDC_DEV_SPEC_PROFILE_TEMP;
    static char *MODEL_NUMBER                       = "GHS-Temp-234r";
    static char *MANUFACTURER_NAME                  = "GHS Ear Thermometer";
    static char *SERIAL_NUMBER                      = "snX-4956";               // The System Info serial number
    static char *FIRMWARE_VERSION                   = "fw90.9";                 // The System Info firmware version
    static char *HARDWARE_VERSION                   = "hw5.7.61";               // The System Info hardware version
    static char *SOFTWARE_VERSION                   = "sw0.0.5";                // The System Info software version

    static char *UDI_LABEL                          = "";
    static char *UDI_DEV_ID                         = "";
    static char *UDI_ISSUER_OID                     = "";
    static char *UDI_AUTH_OID                       = "";

    unsigned char regCertDataList[22]               = { 0, 2, 0, 0x12, 2, 1, 0, 8, 5, 0, 0, 1, 0, 2, 0x80, 8, 2, 2, 0, 2, 0x80, 0 };

    s_MsmtGroupData *msmtGroupTempData              = NULL;
    s_MsmtGroupData *msmtGroupOptimizedTempData     = NULL;
    short temp_index                                = -1;
    short ambient_index                             = -1;
#endif

/** ================================================ SEQUENCE ===========================
    The order of calling these methods is
        1. configureSpecializations(void): This is called prior to advertising to set up the data array templates to be sent to
            to the client.
        2. generateAndAddStoredMsmt(unsigned long long timeStamp, unsigned short numberOfStoredMsmtGroups): This method is called
            currently by a button press (Button 4 on the DK). This creates a fake measurement set for the given specialization and
            stores. It's simulating real data coming from a sensor and being stored because the device is not online. Each button
            press generate a measurement set. For the spirometer, this button does nothing. Stored data is not generated. For the
            Glucose, only stored data is generated. No live data is generated.
        3. handleSpecializationsOnSetTime(unsigned short numberOfStoredMsmtGroups, long long diff, unsigned short timeSync): This method
            is called if your device supports the set time operation and a set time is judged as needed by the client. This updates
            the epoch base and the time sync state of the current time (and any timestamps). Any stored data's time stamps are also
            readjusted appropriately. There is no date-time-adjustment in this model.
        4. sendStoredSpecializationMsmts(unsigned short stored_count): This method is called if there is stored data and the client
            asks to retrieve it. The stored data is queued and then sent until all gone.
        4. bool encodeSpecializationMsmts(void *data): This method is called at any time there is data in the queue. In the main loop
            queued data are obtained and this method is called. If the method succeeds, the measurement is dequeued and the send
            flag set. The main loop calls the send-data method if the send flag is set.
        5. void deleteStoredSpecializationMsmts(void): This method is called if there is stored data. Typcially it is called after
            the cleint uploads the stored data unless, for some reason, it does not want to delete it.
        6. generateLiveDataForSpecializations(unsigned long live_data_count, unsigned long long timeStamp): This method actually has
            been called since program startup but since live data has not been flagged as permitted, the method just returns. Otherwise
            it generates fake data. This method is supposed to simulate events coming from the sensor while connected. The data is 
            generated and then queued. The same procedure happens here as with the sending of stored data.
        7. cleanUpSpecializations(void): This method is called on disconect. It frees all the allocated data arrays created in the
            the configureSpecializations() method
 *
 */

unsigned char *getBtAddress(void)
{
    return bluetoothAddress;
}

/**
 * This method configures and creates the data arrays to be sent to the client.
 * We call this method at start up before any connection or advertising takes place.
 *
 * Creates the system info, current time info, and measurement group data arrays that are sent over
 * the airwaves. These data array templates (except for the SystemInfo) need to be populated
 * with the current data before sending. For example, the current time has to be entered into
 * the current time info data array before sending to the PHG. The same for the measurement
 * data arrays; they will need to be populated with time stamps and values as they are received
 * from the sensors. There are methods to populate the data arrays with that sensor data.
 */
void configureSpecializations(void)
{
    bool result;
    msmt_id = 1;

    // NOTE: We are bad boys and do not check the 'result' value. If false, something went bad, almost always due to
    // implementation bugs.

    // Now to configure our GHS PHD information
    // Create the time info data buffer,  but first establish our GhsTime which we
    // will update as needed.
    #if (USES_TIMESTAMP == 1)
        factor = 1000L; // 10000L for GHS_TIME_FLAG_SUPPORTS_TENTHS_MILLIS
                        // 1000L for GHS_TIME_FLAG_SUPPORTS_MILLISECONDS
                        // 100L for GHS_TIME_FLAG_SUPPORTS_HUNDREDTHS
                        // 1L for GHS_TIME_FLAG_SUPPORTS_SECONDS
        // Method allocates the s_GhsTime structure and populates it with the information
        // it can at the moment.
        result = createGhsTime(&sGhsTime,           // Structure to be allocated. The initial pointer must be NULL. Note that
                                                    // we pass in a pointer to the pointer so when the method completes, the
                                                    // structure will be populated.
                      GHS_TIME_OFFSET_UNSUPPORTED,  // We do not support an offset to UTC. Most devices don't!
                      GHS_TIME_FLAGS_EPOCH_TIME,    // Clock type being used - using the UTC epoch
                      GHS_TIME_FLAG_SUPPORTS_MILLISECONDS, // indicates our clock has a resolution of milliseconds. 
                      INFRA_MDC_TIME_SYNC_NONE);    // The initial synchronization state of the clock. We set it to none which
                                                    // tells the client to set the time if we choose to support the set time.
                                                    // Note that this standard requires that all devices that support a time
                                                    // stamp must be able to report their current time. Given that, the client
                                                    // can ALWAYs correct the times to the correct time IF the client is synchronized,
                                                    // which we assume is the case, even if the device is never synchronized.
        result = createTimeInfo(&sTimeInfo,         // A pointer to an s_TimeInfo structure which we will use to create the sTimeInfoData
                                                    // struct containing the data array to be sent to the client when the client asks
                                                    // for the current time info. It needs to be NULL when passed in. Space is allocated
                                                    // for the structure and is populated by this method.
                            sGhsTime,               // A pointer to the s_GhsTime struct that we populated earlier. If we don't want to 
                                                    // support a time clock at all, this parameter shall be NULL.
                            true);                  // When 'true' we support the set time operation. This value is ignored for relative times
                                                    // and no times.
        result = createCurrentTimeDataBuffer(&sTimeInfoData, sTimeInfo);  // This method creates the time info data array structure from 
                                                                      // the s_TimeInfo struct. We will need to populate the current time
                                                                      // part of this array when the client asks for it. That is done by
                                                                      // various update methods.
                                                                      // Resources need to be cleaned up at program termination. We do it on shutdown
        cleanUpTimeInfo(&sTimeInfo);                // We no longer need the s_TimeInfo structure now that we have created the time info data array.
                                                    // All future updates are done on that data array. So free all it's resources.
    #endif
    // Create the system info data buffer. Here is where we set info like the serial number, specialization, firmware, ect. The idea is to
    // create the system info data buf to get sent to client when it asks for it. The nice thing here is that these values are static, so once
    // created, we are done. No updaters are needed.
    result = createSystemInfo(&systemInfo, 1);              // Allocates and populates the s_SystemInfo struct. We pass in a pointer
                                                            // to a pointer intialized to NULL. The second parameter is the number of specializations
                                                            // supported by the device. In most cases it will be 1.
    result = addSpecialization(&systemInfo, SPECIALIZATION, 2); // Add the specialization and specialization version to system info
    result = setSystemIdentifierByte(&systemInfo, systemId);    // Add the system id to the system info
    result = setRequiredSystemInfoStrings(&systemInfo, MANUFACTURER_NAME, MODEL_NUMBER);    // Add the manufacturer name and model number
                                                                                            // These fields are generally required in most circumstances
                                                                                            // but if this method is not called there will be no failure.
                                                                                            // PLease add these fields!
    result = setRegulationStatus(&systemInfo,     // Set the regulation status.
                                 true,            // If true, a regulation status entry will be added.
                                 false);          // If true, the regulation status is reported as regulated. Ignored if no regulation status is present.
    result = setOptionalSystemInfoStrings(&systemInfo,       // Sets the serial number and the firmware, hardware, and software versions.
                                        SERIAL_NUMBER,       // serial number
                                        FIRMWARE_VERSION,    // firmware version
                                        HARDWARE_VERSION,    // hardware version
                                        SOFTWARE_VERSION);   // software version
    result = setUdi(&systemInfo, UDI_LABEL, UDI_DEV_ID, UDI_ISSUER_OID, UDI_AUTH_OID);
    systemInfo->regCertDataList = regCertDataList;
    systemInfo->regCertDataListLength = 22;

    #if (BP_CUFF == 1)
        // Create the msmt data group      These structures will be used to create the data array to be sent on the wire and then be freed.
        s_MsmtGroup *msmtGroup = NULL;  // structure to hold the msmt group set up
        s_GhsMsmt *bp = NULL;           // structure to hold the blood pressure set up
        s_GhsMsmt *pr = NULL;           // structure to hold the pulse rate set up
        s_GhsMsmt *status = NULL;       // Structure to hold the status set up
        s_Compound compounds[3];        // The Blood pressure measurement is a compound so we need to provide the sub types. We use s_Compound for this
        compounds[0].subType = MDC_PRESS_BLD_NONINV_SYS;    // We only need to provide the sub-type MDC codes in the order we want - first is systolic
        compounds[1].subType = MDC_PRESS_BLD_NONINV_DIA;    // then diastolic
        compounds[2].subType = MDC_PRESS_BLD_NONINV_MEAN;   // then mean
        compounds[0].subUnits = MDC_DIM_MMHG;
        compounds[1].subUnits = MDC_DIM_MMHG;
        compounds[2].subUnits = MDC_DIM_MMHG;
        result = createMsmtGroup(&msmtGroup,    // Now allocate the measurement group and configure it
                                 (USES_TIMESTAMP == 1),          // When true we will use time stamps
                                 3);             // We will have (up to) three measurements in the group, bp, pr, and status
        result = createComplexCompoundNumericMsmt(&bp,                     // Configure the blood pressure measurement which is a compound
                                           MDC_PRESS_BLD_NONINV,    // Provide the overall type for the compound
                                           false,                    // When true, the measurement values are going to use 2-byte SFLOATs instead
                                                                    // of 4-byte FLOATs. This resolution is good enough for the typical bp measurements.
                                           //MDC_DIM_MMHG,            // The units of the blood pressure, here millimeters of Hg
                                           3,                       // The number of components in our compound.
                                           compounds,               // The array of compounds (has the sub types). The values are added in updaters
                                                                    // when we get the data from the sensor.
                                           true);
        result = setGhsMsmtSupplementalTypes(&bp, 1);   // We are going to add a supplemental type to the blood pressure measurement. This supplemental
                                                        // type will indicate the measurement is taken on the upper arm. After we create the data array
                                                        // We will update the array with the MDC code MDC_UPEXT_ARM_UPPER. We will do it here since it is
                                                        // assumed that it does not change during the connection.
        bp_index = addGhsMsmtToGroup(bp, &msmtGroup);   // Now we add the bp measurement to the group. The important thing here for the application is
                                                        // the returned bp_index. The application will need that value in order to update the data array
                                                        // with the bp values received from the sensor.

        result = createNumericMsmt(&pr,                     // Now we add the pulse rate which is a simple numeric. Much simpler.
                                   MDC_PULS_RATE_NON_INV,   // This is the MDC code giving the type of measurement
                                   false,                   // When true, the measurement values are going to be 2-byte SFLOATS
                                   MDC_DIM_BEAT_PER_MIN, true);   // The MDC code for the measurement units - beats per minute.
        pr_index = addGhsMsmtToGroup(pr, &msmtGroup);       // Add this measurement to the group. Again the application will need the pr_index
                                                            // in order to update the data array with pr data from the sensor

        result = createBitsEnumMsmt(&status,                                 // The status measurement which is a special measurement type that
                                                                            // that can contain up to 16 simultaneous events. Each event is represented
                                                                            // by a bit in a 16-bit number. For the bp standard, only six different
                                                                            // status events are defined and they are all events, not states.
                                     MDC_BLOOD_PRESSURE_MEASUREMENT_STATUS, // This is the MDC code indicating that this is a BP status measurement
                                     BP_STATUS_STATES,                      // This value indicates which of the bits are events (0) or states (1).
                                                                            // In the BP cuff, there are only events. So the value is 0.
                                     BP_STATUS_ALL_SUPPORTED,               // This value gives which of the bits are supported. For the BP standard
                                                                            // only bits 0 - 5 are defined. We are not using Mder bit encoding here.
                                     2, false);                             // The size of the bits measurement is two bytes.
        result = setGhsMsmtRefs(&status, 2);           // This method add references to status measurement. The reference will point to the
                                                                // measurement(s) this status event effects. In this case that would be the bp and pr.
                                                                // So when we update the status event, we will call an update method to add the reference
                                                                // (msmt_id) of the BP and PR measurements that were associated with these status events.
        status_index = addGhsMsmtToGroup(status, &msmtGroup);   // Add the status event measurement to the group. Again, the status_index is needed to
                                                                // update the data array with the events and the references.
        reportStatus = true;                                    // First msmt report the status, then flip.

        result = createMsmtGroupDataArray(&msmtGroupBpData,     // Now we create the measurement group data array structure.
                                          msmtGroup,            // Pass in the measurement group to populate this data rray structure
                                          sGhsTime);             // Pass in the s_GhsTime structure to populate the static parts of the time stamp
                                                                // If there is no time stamp, this parameter is NULL. Here we have time stamps.
        result = updateDataGhsMsmtSupplementalTypes(&msmtGroupBpData, bp_index,
                                                                       MDC_UPEXT_ARM_UPPER, 0); // As stated we are going to add the code for the location
                                                                                                // of the BP cuff once now, as we are not expecting it to
                                                                                                // change during the connection. Of course, most devices
                                                                                                // probably wont add this information unless, for some reason
                                                                                                // it could change and be indicated by a UI.


        cleanUpMsmtGroup(&msmtGroup); // Now that we have gotten our data array we do not need the configuration structure anymore. Calling this cleanup
                                      // method also frees the memory allocated for all the measurement set up structures that we added to the group. So
                                      // we do not need to free them UNLESS we did not add them to the msmtGroup.
//        result = updateDataDropLastMsmt(&msmtGroupBpData);  // This special method configures our data array such that when sent, the last measurement, which
                                                   // is the status measurement, will not be sent over the airwaves. This is because, in practice, status
                                                   // events are anticipated to be the exception and not the rule. So instead of sending a status event with
                                                   // a value of all 0s (no events) we remove sending the event from the group. The measurement is still
                                                   // there and should we need it, the application calls updateDataRestoreLastMsmt(&msmtGroupBpData)
                                                   // and then adds the status event data into the data array by calling the appropriate update routine.
    #endif  // BP cuff


    #if (PULSE_OX == 1)
        // Pulse Ox
        // device and sensor status measurement
        #define PO_DEV_STATUS_EXT_DISPLAY_ONGOING 1
        #define PO_DEV_STATUS_EQUIP_MALFUNCTION_DETECTED 2
        #define PO_DEV_STATUS_SIGNAL_PROCESS_IRREG_DETECTED 4
        #define PO_DEV_STATUS_INADEQUATE_SIGNAL_DETECTED 8
        #define PO_DEV_STATUS_POOR_SIGNAL_DETECTED 16
        #define PO_DEV_STATUS_LOW_PERFUSION_DETECTED 32
        #define PO_DEV_STATUS_ERRATIC_SIGNAL_DETECTED 64
        #define PO_DEV_STATUS_NON_PULSATILE_SIGNAL_DETECTED 128
        #define PO_DEV_STATUS_QUEST_PULSE_DETECTED 256
        #define PO_DEV_STATUS_SIGNAL_ANALYSIS_ONGOING 512
        #define PO_DEV_STATUS_SENSOR_INTERFERENCE_DETECTED 1024
        #define PO_DEV_STATUS_SENSOR_NOT_CONNECTED_TO_USER 2048
        #define PO_DEV_STATUS_UNKNOWN_SENSOR_DETECTED 4096
        #define PO_DEV_STATUS_SENSOR_DISPLACED 8192
        #define PO_DEV_STATUS_SENSOR_MALFUNCTIONING 16384
        #define PO_DEV_STATUS_SENSOR_DISCONNECTED 32768

        // Create the msmt data group for SPOT measurements
        s_MsmtGroup *msmtGroup = NULL;
        s_GhsMsmt *spo2 = NULL;
        s_GhsMsmt *pr = NULL;
        s_GhsMsmt *qual = NULL;
        result = createMsmtGroup(&msmtGroup, (USES_TIMESTAMP == 1), 3); // 3 msmts - SpO2, PR, Qual
        result = setHeaderSupplementalTypes(&msmtGroup, 1);
        result = createNumericMsmt(&spo2, MDC_PULS_OXIM_SAT_O2, false, MDC_DIM_PERCENT, false);
        spo2_index = addGhsMsmtToGroup(spo2, &msmtGroup);
        result = createNumericMsmt(&pr, MDC_PULS_OXIM_PULS_RATE, false, MDC_DIM_BEAT_PER_MIN, false);
        pr_index = addGhsMsmtToGroup(pr, &msmtGroup);
        result = createNumericMsmt(&qual, MDC_SAT_O2_QUAL, false, MDC_DIM_PERCENT, false);
        qual_index = addGhsMsmtToGroup(qual, &msmtGroup);
        result = createMsmtGroupDataArray(&msmtGroupSpotData, msmtGroup, sGhsTime);
        updateDataHeaderSupplementalTypes(&msmtGroupSpotData, MDC_MODALITY_SPOT, 0);
        cleanUpMsmtGroup(&msmtGroup); // cleans up any allocated data -  we only need the data array now

        spo2 = NULL;
        pr = NULL;
        qual = NULL;

        // Now for the continuous
        result = createMsmtGroup(&msmtGroup, false, 3); // 3 msmts - SpO2, PR, Qual
        result = createNumericMsmt(&spo2, MDC_PULS_OXIM_SAT_O2, false, MDC_DIM_PERCENT, false);
        spo2_cont_index = addGhsMsmtToGroup(spo2, &msmtGroup);
        result = createNumericMsmt(&pr, MDC_PULS_OXIM_PULS_RATE, false, MDC_DIM_BEAT_PER_MIN, false);
        pr_cont_index = addGhsMsmtToGroup(pr, &msmtGroup);
        result = createNumericMsmt(&qual, MDC_SAT_O2_QUAL, false, MDC_DIM_PERCENT, false);
        qual_cont_index = addGhsMsmtToGroup(qual, &msmtGroup);
        result = createMsmtGroupDataArray(&msmtGroupContData, msmtGroup, NULL);
        cleanUpMsmtGroup(&msmtGroup); // cleans up any allocated data - we only need the data array now
    #endif  // Pulse ox
    #if (GLUCOSE == 1)
        s_MsmtGroup *glucoseGroup = NULL;
        s_GhsMsmt *conc = NULL;
        s_GhsMsmt *meds = NULL;
        s_GhsMsmt *carbs = NULL;
        s_GhsMsmt *exer = NULL;
        result = createMsmtGroup(&glucoseGroup, (USES_TIMESTAMP == 1), 4); // 4 msmts
        result = createNumericMsmt(&conc, MDC_CONC_GLU_UNDETERMINED_PLASMA, false, MDC_DIM_MILLI_G_PER_DL, false);
        result = setGhsMsmtSupplementalTypes(&conc, 4);
        conc_index = addGhsMsmtToGroup(conc, &glucoseGroup);
        result = createNumericMsmt(&meds, MDC_CTXT_MEDICATION, false, MDC_DIM_INTL_UNIT, false);
        result = setGhsMsmtSupplementalTypes(&meds, 1);
        meds_index = addGhsMsmtToGroup(meds, &glucoseGroup);
        result = createNumericMsmt(&carbs, MDC_CTXT_GLU_CARB, false, MDC_DIM_G, false);
        result = setGhsMsmtSupplementalTypes(&carbs, 1);
        carbs_index = addGhsMsmtToGroup(carbs, &glucoseGroup);
        result = createNumericMsmt(&exer, MDC_CTXT_GLU_EXERCISE, false, MDC_DIM_PERCENT, false);
        // TODO - make this observational with an updateData...
        result = setGhsMsmtDuration(&exer);
        exer_index = addGhsMsmtToGroup(exer, &glucoseGroup);
        result = createMsmtGroupDataArray(&msmtGroupGlucData, glucoseGroup, sGhsTime);
        s_MderFloat mder;
        mder.exponent = 0;
        mder.mantissa = 3600;
        mder.mderFloatType = MDER_FLOAT;
        mder.specialValue = MDER_NUMBER;
        updateDataGhsMsmtDuration(&msmtGroupGlucData, exer_index, &mder);
        cleanUpMsmtGroup(&glucoseGroup);
    #endif
    #if (HEART_RATE == 1)
        s_MsmtGroup *hrGroup = NULL;
        s_GhsMsmt *hrMsmt = NULL;
        createMsmtGroup(&hrGroup, (USES_TIMESTAMP == 1), 1);
        createNumericMsmt(&hrMsmt, MDC_ECG_HEART_RATE, false, MDC_DIM_BEAT_PER_MIN, false);
        hr_index = addGhsMsmtToGroup(hrMsmt, &hrGroup);
        createMsmtGroupDataArray(&msmtGroupHrData, hrGroup, NULL);
        cleanUpMsmtGroup(&hrGroup);        
    #endif

    #if (SPIROMETER == 1)
        spiro_sequence = 0;
        // Going to load all the data here and send it in chunks on the 'live' command and then stop.
        // The only update will be the time stamps
        s_MsmtGroup *spiroSettingsGroup = NULL;
        s_GhsMsmt *age = NULL;
        s_GhsMsmt *weight = NULL;
        s_GhsMsmt *height = NULL;
        s_GhsMsmt *sex = NULL;
        s_GhsMsmt *ethnicity = NULL;

        s_MsmtGroup *spiroSessionGroup = NULL;
        s_GhsMsmt *session = NULL;
        s_MsmtGroup *spiroSessionEndGroup = NULL;
        s_GhsMsmt *sessionEnd = NULL;

        s_MsmtGroup *spiroSubSessionGroup = NULL;
        s_GhsMsmt *sub_session = NULL;
        s_MsmtGroup *spiroSubSessionEndGroup = NULL;
        s_GhsMsmt *sub_sessionEnd = NULL;

        s_MsmtGroup *spiroStreamingGroup = NULL;
        s_GhsMsmt *volume = NULL;
        s_GhsMsmt *flow = NULL;

        s_MsmtGroup *spiroManeuvGroup = NULL;
        s_GhsMsmt *fev05 = NULL;
        s_GhsMsmt *fev075 = NULL;
        s_GhsMsmt *fev1 = NULL;
        s_GhsMsmt *fev3 = NULL;
        s_GhsMsmt *fev6 = NULL;
        s_GhsMsmt *fvc = NULL;
        s_GhsMsmt *pef = NULL;
        s_GhsMsmt *fef25 = NULL;
        s_GhsMsmt *fef50 = NULL;
        s_GhsMsmt *fef75 = NULL;
        s_GhsMsmt *fef25_75 = NULL;
        s_GhsMsmt *fet = NULL;
        s_GhsMsmt *tpef = NULL;
        s_GhsMsmt *extrap = NULL;
        s_GhsMsmt *temp = NULL;
        s_GhsMsmt *humid = NULL;
        s_GhsMsmt *airPress = NULL;
        s_GhsMsmt *fev1z = NULL;
        s_GhsMsmt *fev1_lln = NULL;
        s_GhsMsmt *fev1_percent_pred = NULL;

        s_MsmtGroup *spiroSummaryGroup = NULL;
        s_GhsMsmt *fvcAtsGrade = NULL;
        s_GhsMsmt *fev1AtsGrade = NULL;

        // session
        result = createMsmtGroup(&spiroSessionGroup, (USES_TIMESTAMP == 1), 1); // 1 msmt
        result = createCodedMsmt(&session, MDC_DIAG_SESSION_SPIRO, true);
        session_index = addGhsMsmtToGroup(session, &spiroSessionGroup);
        createMsmtGroupDataArray(&msmtGroupSpiroSessionData, spiroSessionGroup, sGhsTime);
        session_id = msmt_id;
        updateDataCoded(&msmtGroupSpiroSessionData, session_index, MDC_START, msmt_id++);
        cleanUpMsmtGroup(&spiroSessionGroup);

        // settings
        result = createMsmtGroup(&spiroSettingsGroup,
                                    (USES_TIMESTAMP == 1),       // has time stamps
                                        5);     // number of measurements

        result = setHeaderOptions(&spiroSettingsGroup,
                                    true,       // are settings
                                    false,      // has person id
                                    0);         // person id
        result = setHeaderRefs(&spiroSettingsGroup, 1);
        result = createNumericMsmt(&age, MDC_HF_AGE, false, MDC_DIM_YR, true);
        result = createNumericMsmt(&weight, MDC_MASS_BODY_ACTUAL, false, MDC_DIM_KILO_G, true);
        result = createNumericMsmt(&height, MDC_LEN_BODY_ACTUAL, false, MDC_DIM_CENTI_M, true);
        result = createCodedMsmt(&ethnicity, MDC_ETHNICITY, true);
        result = createCodedMsmt(&sex, MDC_BIRTH_SEX, true);
        age_index = addGhsMsmtToGroup(age, &spiroSettingsGroup);
        weight_index = addGhsMsmtToGroup(weight, &spiroSettingsGroup);
        height_index = addGhsMsmtToGroup(height, &spiroSettingsGroup);
        ethnicity_index = addGhsMsmtToGroup(ethnicity, &spiroSettingsGroup);
        sex_index = addGhsMsmtToGroup(sex, &spiroSettingsGroup);
        result = createMsmtGroupDataArray(&msmtGroupSpiroSettingsData, spiroSettingsGroup, sGhsTime);
        updateDataHeaderRefs(&msmtGroupSpiroSettingsData, session_id, 0);

        s_MderFloat mder;
        mder.exponent = 0;
        mder.mantissa = AGE;
        mder.mderFloatType = MDER_FLOAT;
        mder.specialValue = MDER_NUMBER;
        settings_id[0] = msmt_id;
        updateDataNumeric(&msmtGroupSpiroSettingsData, age_index, &mder, msmt_id++);
        mder.exponent = -2;
        mder.mantissa = WEIGHT;
        mder.mderFloatType = MDER_FLOAT;
        settings_id[1] = msmt_id;
        updateDataNumeric(&msmtGroupSpiroSettingsData, weight_index, &mder, msmt_id++);
        mder.exponent = -1;
        mder.mantissa = HEIGHT;
        mder.mderFloatType = MDER_FLOAT;
        settings_id[2] = msmt_id;
        updateDataNumeric(&msmtGroupSpiroSettingsData, height_index, &mder, msmt_id++);
        settings_id[3] = msmt_id;
        updateDataCoded(&msmtGroupSpiroSettingsData, ethnicity_index, MDC_ETHNICITY_WHITE, msmt_id++);
        settings_id[4] = msmt_id;
        updateDataCoded(&msmtGroupSpiroSettingsData, sex_index, MDC_BIRTH_SEX_MALE, msmt_id++);
        cleanUpMsmtGroup(&spiroSettingsGroup);

        // sub session
        result = createMsmtGroup(&spiroSubSessionGroup, (USES_TIMESTAMP == 1), 1); // 1 msmt
        setHeaderRefs(&spiroSubSessionGroup, 1 );
        result = createCodedMsmt(&sub_session, MDC_DIAG_SUB_SESSION_SPIRO_MANEUVER, true);
        sub_session_index = addGhsMsmtToGroup(sub_session, &spiroSubSessionGroup);
        createMsmtGroupDataArray(&msmtGroupSpiroSubSessionData, spiroSubSessionGroup, sGhsTime);
        cleanUpMsmtGroup(&spiroSubSessionGroup);

        // streaming data
        result = createMsmtGroup(&spiroStreamingGroup, (USES_TIMESTAMP == 1), 1); // 1 msmt
        setHeaderRefs(&spiroStreamingGroup, 1 );
        s_MderFloat period;
        period.exponent = -3;
        period.mantissa = 10;  // 10 milliseconds; 0.01 seconds
        period.mderFloatType = MDER_FLOAT;
        period.specialValue = MDER_NUMBER;
        s_MderFloat scaleFactor;
        scaleFactor.exponent = 0;
        scaleFactor.mantissa = 1;  // raw data will be milliliters
        scaleFactor.mderFloatType = MDER_FLOAT;
        scaleFactor.specialValue = MDER_NUMBER;
        s_MderFloat offset;
        offset.exponent = 0;
        offset.mantissa = 0;  // raw data will be milliliters
        offset.mderFloatType = MDER_FLOAT;
        offset.specialValue = MDER_NUMBER;
      //  result = createRtsaMsmt(&volume, MDC_VOL_AWAY, MDC_DIM_MILLI_L, &period, &scaleFactor, &offset, NO_OF_SAMPLES, SAMPLE_SIZE);
        result = createRtsaMsmt(&flow, MDC_FLOW_AWAY, MDC_DIM_MILLI_L_PER_SEC, &period, &scaleFactor, &offset, NO_OF_SAMPLES, SAMPLE_SIZE, true);
        flow->rtsa->scaledMin = 0;
        flow->rtsa->scaledMax = 100;
      //  volume_index = addGhsMsmtToGroup(volume, &spiroStreamingGroup);
        setHeaderRefs(&spiroStreamingGroup, 1 );
        flow_index = addGhsMsmtToGroup(flow, &spiroStreamingGroup);
        createMsmtGroupDataArray(&msmtGroupSpiroStreamData, spiroStreamingGroup, sGhsTime);
        cleanUpMsmtGroup(&spiroStreamingGroup);


        // maneuver results
        result = createMsmtGroup(&spiroManeuvGroup, (USES_TIMESTAMP == 1), 8); // 8 msmts for now
        setHeaderRefs(&spiroManeuvGroup, 1);
        result = createNumericMsmt(&fev1, MDC_VOL_AWAY_EXP_FORCED_1S, false, MDC_DIM_L, true);
        result = createNumericMsmt(&fev6, MDC_VOL_AWAY_EXP_FORCED_6S, false, MDC_DIM_L, true);
        result = createNumericMsmt(&fvc, MDC_VOL_AWAY_EXP_FORCED_CAPACITY, false, MDC_DIM_L, true);
        result = createNumericMsmt(&pef, MDC_FLOW_AWAY_EXP_FORCED_PEAK, false, MDC_DIM_L_PER_SEC, true);
        result = createNumericMsmt(&fet, MDC_VOL_AWAY_EXP_FORCED_TIME, false, MDC_DIM_SEC, true);
        result = createNumericMsmt(&fev1z, MDC_VOL_AWAY_FEV1_Z_SCORE, false, MDC_DIM_DIMLESS, true);
        result = createNumericMsmt(&fev1_lln, MDC_VOL_AWAY_FEV1_LLN, false, MDC_DIM_L, true);
        result = createNumericMsmt(&fev1_percent_pred,  MDC_VOL_AWAY_FEV1_PERCENT_PRED, false, MDC_DIM_PERCENT, true);

        fev1_index = addGhsMsmtToGroup(fev1, &spiroManeuvGroup);
        fev6_index = addGhsMsmtToGroup(fev6, &spiroManeuvGroup);
        fvc_index = addGhsMsmtToGroup(fvc, &spiroManeuvGroup);
        pef_index = addGhsMsmtToGroup(pef, &spiroManeuvGroup);
        fet_index = addGhsMsmtToGroup(fet, &spiroManeuvGroup);
        fev1z_index = addGhsMsmtToGroup(fev1z, &spiroManeuvGroup);
        setGhsMsmtSupplementalTypes(&fev1z, 1);  // Reserve space for one supplemental types for prediction equation
        setGhsMsmtRefs(&fev1z, 6);
        fev1_lln_index = addGhsMsmtToGroup(fev1_lln, &spiroManeuvGroup);
        setGhsMsmtSupplementalTypes(&fev1_lln, 1);  // Reserve space for one supplemental types for prediction equation
        setGhsMsmtRefs(&fev1_lln, 5);
        fev1_percent_pred_index = addGhsMsmtToGroup(fev1_percent_pred, &spiroManeuvGroup);
        setGhsMsmtSupplementalTypes(&fev1_percent_pred, 1);  // Reserve space for one supplemental types for prediction equation
        setGhsMsmtRefs(&fev1_percent_pred, 6);

        createMsmtGroupDataArray(&msmtGroupSpiroManeuvData, spiroManeuvGroup, sGhsTime);
        updateDataGhsMsmtSupplementalTypes(&msmtGroupSpiroManeuvData, fev1z_index, MDC_SPIRO_PRED_EQN_NHANESIII, 0);
        updateDataGhsMsmtSupplementalTypes(&msmtGroupSpiroManeuvData, fev1_lln_index, MDC_SPIRO_PRED_EQN_NHANESIII, 0);
        updateDataGhsMsmtSupplementalTypes(&msmtGroupSpiroManeuvData, fev1_percent_pred_index, MDC_SPIRO_PRED_EQN_NHANESIII, 0);
        cleanUpMsmtGroup(&spiroManeuvGroup);

        // summary
        // It makes not sense to create this data array here as the number of references will be unknown until
        // the session ends. Then we pick the best 3 best FVC and FEV1 values and use that. Then we fill in
        // the refs which ideally will have up to three entries in addition to the session_id.
        result = createMsmtGroup(&spiroSummaryGroup, (USES_TIMESTAMP == 1), 2); // 1 msmts
        setHeaderRefs(&spiroSummaryGroup, 1);
        result = createCodedMsmt(&fvcAtsGrade, MDC_SPIRO_FVC_ATS_QUAL, true);
        setGhsMsmtRefs(&fvcAtsGrade, 2);
        result = createCodedMsmt(&fev1AtsGrade, MDC_SPIRO_FEV1_ATS_QUAL, true);
        setGhsMsmtRefs(&fev1AtsGrade, 2);
        fvcAtsGrade_index = addGhsMsmtToGroup(fvcAtsGrade, &spiroSummaryGroup);
        fev1AtsGrade_index = addGhsMsmtToGroup(fev1AtsGrade, &spiroSummaryGroup);
        createMsmtGroupDataArray(&msmtGroupSpiroSummaryData, spiroSummaryGroup, sGhsTime);
        cleanUpMsmtGroup(&spiroSummaryGroup);

        // session end
        result = createMsmtGroup(&spiroSessionEndGroup, (USES_TIMESTAMP == 1), 1); // 1 msmt
        setHeaderRefs(&spiroSessionEndGroup, 1);
        result = createCodedMsmt(&sessionEnd, MDC_DIAG_SESSION_SPIRO, true);
        session_end_index = addGhsMsmtToGroup(sessionEnd, &spiroSessionEndGroup);
        createMsmtGroupDataArray(&msmtGroupSpiroSessionEndData, spiroSessionEndGroup, sGhsTime);
        cleanUpMsmtGroup(&spiroSessionEndGroup);
    #endif
    #if (SCALE == 1)
        s_MsmtGroup *msmtGroup = NULL;
        s_MsmtGroup *settingsGroup = NULL;
        s_GhsMsmt *mass = NULL;
        s_GhsMsmt *height = NULL;
        s_GhsMsmt *bmi = NULL;

        // Create the msmt data group for the settings measurements, in this case the height.
        result = createMsmtGroup(&settingsGroup, false, 1); // 1 msmt height
        result = setHeaderOptions(&settingsGroup, true, true, 2);  // indicate these are settings and include a person Id
        result = createNumericMsmt(&height, MDC_LEN_BODY_ACTUAL, false, MDC_DIM_CENTI_M, true);
        height_index = addGhsMsmtToGroup(height, &settingsGroup);
        result = createMsmtGroupDataArray(&settingsGroupData, settingsGroup, sGhsTime);
        // Populate the settings measurement data array with the settings height value. This need only be done once
        // unless, for some reason, the setting changes. Here we assume it is not to change while connected.
        s_MderFloat mder;
        mder.mderFloatType = MDER_FLOAT;
        mder.specialValue = MDER_NUMBER;
        mder.exponent = -1;
        mder.mantissa = HEIGHT;
        mder.mderFloatType = MDER_SFLOAT;
        height_ref = msmt_id;               // Save the msmt_id value so the BMI msmts can point to it.
        result = updateDataNumeric(&settingsGroupData, height_index, &mder, msmt_id++); // Create final measurement - this is a setting.
        cleanUpMsmtGroup(&settingsGroup); // cleans up any allocated data -  we only need the data array now

        // Create the measurement group for the mass and bmi.
        result = createMsmtGroup(&msmtGroup, (USES_TIMESTAMP == 1), 2); // 2 msmts mass, BMI
        result = setHeaderOptions(&msmtGroup, false, true, 2);  // include a person Id
        result = createNumericMsmt(&mass, MDC_MASS_BODY_ACTUAL, false, MDC_DIM_KILO_G, true); // Create a numeric msmt for the body mass
        mass_index = addGhsMsmtToGroup(mass, &msmtGroup);       // add it to the group
        result = createNumericMsmt(&bmi, MDC_RATIO_MASS_BODY_LEN_SQ, false, MDC_DIM_KG_PER_M_SQ, false); // Create a numeric msmt for the BMI
        result = setGhsMsmtRefs(&bmi, 2);              // Make room for two references in the BMI; one to height, the other to mass
        bmi_index = addGhsMsmtToGroup(bmi, &msmtGroup);         // add the msmt to the group
        result = createMsmtGroupDataArray(&msmtGroupScaleData, msmtGroup, sGhsTime); // Create the data packet and support info
        cleanUpMsmtGroup(&msmtGroup); // cleans up any allocated data -  we only need the data array now
    #endif  // Ear thermometer
    #if (THERMOMETER == 1)
        // Create the msmt data group 
        s_MsmtGroup *msmtGroup = NULL;
        s_GhsMsmt *temp = NULL;
        s_GhsMsmt *ambient = NULL;
        result = createMsmtGroup(&msmtGroup, (USES_TIMESTAMP == 1), 2); // 2 msmts - body temp & ambient temp
        result = createNumericMsmt(&temp, MDC_TEMP_EAR, false, MDC_DIM_FAHR, false);
        temp_index = addGhsMsmtToGroup(temp, &msmtGroup);
        result = createNumericMsmt(&ambient, MDC_TEMP_ROOM, false, MDC_DIM_FAHR, false);
        ambient_index = addGhsMsmtToGroup(ambient, &msmtGroup);
        result = createMsmtGroupDataArray(&msmtGroupTempData, msmtGroup, sGhsTime);
        cleanUpMsmtGroup(&msmtGroup); // cleans up any allocated data -  we only need the data array now
    #endif  // Ear thermometer
}

/**
 * This method is called indirectly from the main loop via encodeMsmtData method. The first method just checks the
 * bluetooth state/process to see if data is ready to be encoded. In any case, when it get here the data structs containing
 * the data from the sensors have been populated and now we just have to stick them in the data array. Since this method
 * is called by different specializations each requiring their own information, what is queued is void* pointer and size
 * parameter. Here we need to cast the void* to the specialization-specific structure.
 */
bool encodeSpecializationMsmts(s_MsmtData *msmt)
{
    #if (BP_CUFF == 1)
        s_MderFloat mder[3];                            // Since it the Blood Pressure we need to provide the three values
                                                        // obtained from the sensors. This stage is a little tricky, as we
                                                        // need to pass precision information and maintain that throughout the
                                                        // transfer. The IEEE 11073 20601 SFLOAT and FLOATs are used. The
                                                        // library will do this for you but you need to populate an s_MderFloat
                                                        // struct for each value. We can see how that is done below.
        if (!prepareMeasurements(msmtGroupBpData, msmt->common.recordNumber)) return false;    // This method initalizes a structure needed for the send
                                                                    // method. This includes the length of the data array
                                                                    // and the characteristic it is to be notified on. The necessary
                                                                    // information is contained in the data array structure msmtGroupBpData.
                                                                    // The structure populated is the s_global_send structure.
                                                                    // Recall that this model is synchronous.

        mder[0].mderFloatType = MDER_FLOAT;     // Now to create the Mder Floats. We are using 2-byte SFLOAT
        mder[0].specialValue = MDER_NUMBER;     // This SFLOAT is going to be number versus a special value as a NAN, PINF r NINF
        mder[0].exponent = 0;                   // The exponent of 0 means this is an integer with no decimal precison
        mder[0].mantissa = msmt->systolic;        // This is the mantissa which is this case is the value retrieved from our fake sensors.
                                                // Now if our sensors sent a systolic value with tenths precision, it would probably send
                                                // an integer like 1232 to represent 123.2 since it is much easier to do. Then you would
                                                // enter -1 in the exponent and 1232 in the mantissa. In the end, the value is given by
                                                // mantissa * 10 ** exponent. However, the exponent has a further meaning of precision
                                                // such that one can send either 2, 2.0, 2.00, etc. They are all the same value but indicate
                                                // different sensor precisions.
        mder[1].mderFloatType = MDER_FLOAT;
        mder[1].specialValue = MDER_NUMBER;
        mder[1].exponent = 0;
        mder[1].mantissa = msmt->diastolic;       // Same as for systolic but for diastolic
        mder[2].mderFloatType = MDER_FLOAT;
        mder[2].specialValue = MDER_NUMBER;
        mder[2].exponent = 0;
        mder[2].mantissa = msmt->mean;            // Same as for systolic but for mean.

        updateDataGhsMsmtRefs(&msmtGroupBpData, // This method may seem a little out of place, but it is to add the references to the
                                                        // bp and pr measurements for the status event. Every GHS measurement has a unique
                                                        // instance number over a connection, here given by msmt_id. The current msmt_id value
                                                        // is going to be for the blood pressure measurement coming up so we add that value 
                                                        // here to the status measurement
                                      status_index,     // This status_index states we will add the msmt_id to status measurement reference list.
                                      msmt_id,          // This is the reference instance
                                      0);               // This is the index of the reference we are adding. At the start we allocated space
                                                        // for two reference numbers. Here we are doing the first one. If the number is out of
                                                        // bounds it wont get added.

        updateDataCompound(&msmtGroupBpData,    // Now we update the data array with the blood pressure values. The method expects the
                                                // measurement to be updated to be the configured compound thus 'updateDataCOMPOUND'
                           bp_index,            // The bp_index indicates that the value update is to be done to the blood pressure. The
                                                // method will check that the measurement is, in fact, a compound.
                           mder,                // This is the array of s_MderFloats containing the bp values with their precision
                           msmt_id++);          // This is the instance number for the bp measurement. We increment msmt_id to use in the
                                                // next measurement
        mder[0].mantissa = msmt->pulseRate;       // Now for the pulse rate. We will reuse the first of our s_MderFloats. All the supporting
                                                // parameters are the same. We need only set the mantissa.

        updateDataGhsMsmtRefs(&msmtGroupBpData, status_index, msmt_id, 1); // Now since the current msmt_id is going to be the instance
                                                                                   // number for the pulse rate, we add that value to the status
                                                                                   // measurement reference list. But it is now the second entry.
        updateDataNumeric(&msmtGroupBpData,     // Now we update the pulse rate in the data array which is a numeric
                          pr_index,             // Tells the updater which measurement in the group the pulse rate is
                          &mder[0],             // The value of the pulse rate with precision
                          msmt_id++);           // The instance number for the pulse rate which is then incremented.
        if (msmt->hasStatus)
        {
            updateDataBits(&msmtGroupBpData,    // Now we update the status measurement which is a 16-bit event/state measurement
                                                // Note we could check that the status flags are all zero. In that case we simply
                                                // could skip sending this measurement. But in this demo we just toggle between
                                                // sending the status and not sending it. Our fake data generator always generate status
                                                // values. Hopefully a real device won't send status events all the time.
                         status_index,                      // This status_index indicates that these updates are for the status measurement
                         (msmt->status_cuff_too_loose         // These are the possible status flags that could have been set in our bp measurement.
                        | msmt->status_improper_position
                        | msmt->status_irregular_pulse
                        | msmt->status_movement),
                         msmt_id++);             // The instance number for the sensor status which is then incremented.
        }
        updateTimeStampEpoch(&msmtGroupBpData, msmt->common.sGhsTime.epoch);  // Now we call the update method to populate the time stamp. In our fake
                                                                     // data generator we get the current clock tick, add it to the base-epoch
                                                                     // and place that into the bp measurement structure.
        NRF_LOG_DEBUG("Bp msmt to send");       // Now we have the data array to send to the client. In the main for-loop the send-Flag has been
                                                // set which will cause this data to be sent.
    #endif
    #if (PULSE_OX == 1)
        s_MderFloat mder;
        mder.mderFloatType = MDER_FLOAT;
        mder.specialValue = MDER_NUMBER;
        if (msmt->isContinuous)
        {
            s_MsmtGroupData *bytes = msmtGroupContData;
            if (!prepareMeasurements(bytes, 0)) return false;

            mder.exponent = 0;
            mder.mantissa = msmt->spo2;
            updateDataNumeric(&bytes, spo2_cont_index, &mder, msmt_id++);
            mder.mantissa = msmt->pulseRate;
            updateDataNumeric(&bytes, pr_cont_index, &mder, msmt_id++);
            mder.mantissa = msmt->pulseQuality;
            mder.exponent = -2;
            updateDataNumeric(&bytes, qual_cont_index, &mder, msmt_id++);
            NRF_LOG_DEBUG("Continuous msmt to send");
        }
        else
        {
            if (!prepareMeasurements(msmtGroupSpotData, msmt->common.recordNumber)) return false;

            mder.exponent = 0;
            mder.mantissa = msmt->spo2;
            updateDataNumeric(&msmtGroupSpotData, spo2_index, &mder, msmt_id++);
            mder.mantissa = msmt->pulseRate;
            updateDataNumeric(&msmtGroupSpotData, pr_index, &mder, msmt_id++);
            mder.mantissa = msmt->pulseQuality;
            mder.exponent = -2;
            updateDataNumeric(&msmtGroupSpotData, qual_index, &mder, msmt_id++);
            NRF_LOG_DEBUG("Spot msmt to send");
            updateTimeStampEpoch(&msmtGroupSpotData, msmt->common.sGhsTime.epoch);
        }
    #endif
    #if (GLUCOSE == 1)
        s_MderFloat mder;
        if (!prepareMeasurements(msmtGroupGlucData, msmt->common.recordNumber)) return false;

        mder.specialValue = MDER_NUMBER;
        mder.exponent = -1;
        mder.mantissa = msmt->conc;
        mder.mderFloatType = MDER_FLOAT;
        unsigned short ref = msmt_id;
        updateDataNumeric(&msmtGroupGlucData, conc_index, &mder, msmt_id++);
        updateDataGhsMsmtSupplementalTypes(&msmtGroupGlucData, conc_index, msmt->meal_context, 0);
        updateDataGhsMsmtSupplementalTypes(&msmtGroupGlucData, conc_index, msmt->body_site, 1);
        updateDataGhsMsmtSupplementalTypes(&msmtGroupGlucData, conc_index, msmt->health, 2);
        updateDataGhsMsmtSupplementalTypes(&msmtGroupGlucData, conc_index, msmt->tester, 3);
        mder.exponent = 0;
        mder.mantissa = msmt->carbs;
        updateDataNumeric(&msmtGroupGlucData, carbs_index, &mder, msmt_id++);
        updateDataGhsMsmtSupplementalTypes(&msmtGroupGlucData, carbs_index, msmt->carbs_type, 0);
        mder.exponent = -1;
        mder.mantissa = msmt->meds;
        updateDataNumeric(&msmtGroupGlucData, meds_index, &mder, msmt_id++);
        updateDataGhsMsmtSupplementalTypes(&msmtGroupGlucData, meds_index, msmt->medication_type, 0);
        mder.exponent = 0;
        mder.mantissa = msmt->exer;
        updateDataNumeric(&msmtGroupGlucData, exer_index, &mder, msmt_id++);
        updateTimeStampEpoch(&msmtGroupGlucData, msmt->common.sGhsTime.epoch);
        NRF_LOG_DEBUG("Bp msmt to send");
    #endif
    #if (HEART_RATE == 1)
        s_MderFloat mder;
        if (!prepareMeasurements(msmtGroupHrData, 0)) return false;
        mder.specialValue = MDER_NUMBER;
        mder.exponent = 0;
        mder.mantissa = msmt->heartRate;
        mder.mderFloatType = MDER_FLOAT;
        updateDataNumeric(&msmtGroupHrData, hr_index, &mder, msmt_id++);
    #endif
    // We are not generating the measurements on the fly as in the other cases, it is all pre done
    // except for the time stamps.
    #if (SPIROMETER == 1)
        s_MsmtData *session = msmt;
        if (spiro_sequence == 0)
        {
            if (!prepareMeasurements(msmtGroupSpiroSessionData, 0)) return false;
            NRF_LOG_DEBUG("Sending Spirometer session");
            updateTimeStampEpoch(&msmtGroupSpiroSessionData, session->common.sGhsTime.epoch);
            msmt_id = 1;  // resetting the msmt id because the session end updates it
            updateDataCoded(&msmtGroupSpiroSessionData, session_index, MDC_START, msmt_id);
            msmt_id = 7;    // Skip to 7 for the pre-set settings ids
        }
        if (spiro_sequence == 1)
        {
            if (!prepareMeasurements(msmtGroupSpiroSettingsData, 0)) return false;
            updateTimeStampEpoch(&msmtGroupSpiroSettingsData, session->common.sGhsTime.epoch);
            NRF_LOG_DEBUG("Sending Spirometer settings");
        }
        else if (spiro_sequence == 2)
        {
            if (!prepareMeasurements(msmtGroupSpiroSubSessionData, 0)) return false;
            updateDataHeaderRefs(&msmtGroupSpiroSubSessionData, session_id, 0);
            NRF_LOG_DEBUG("Sending first maneuver Spirometer sub session");
            updateTimeStampEpoch(&msmtGroupSpiroSubSessionData, session->common.sGhsTime.epoch);
            sub_session_id = msmt_id;
            updateDataCoded(&msmtGroupSpiroSubSessionData, sub_session_index, MDC_START, msmt_id++);
        }
        else if (spiro_sequence == 3)
        {
            NRF_LOG_DEBUG("Sending Spirometer flow and volume streams 1");
            if (!prepareMeasurements(msmtGroupSpiroStreamData, 0)) return false;
            updateTimeStampEpoch(&msmtGroupSpiroStreamData, session->common.sGhsTime.epoch);
            updateDataHeaderRefs(&msmtGroupSpiroStreamData, sub_session_id, 0);
            updateDataRtsa(&msmtGroupSpiroStreamData, flow_index, flowBytes, NO_OF_SAMPLES * SAMPLE_SIZE, msmt_id++);
        }
        else if (spiro_sequence == 4)
        {
            NRF_LOG_DEBUG("Sending Spirometer flow and volume streams 2");
            if (!prepareMeasurements(msmtGroupSpiroStreamData, 0)) return false;
            updateTimeStampEpoch(&msmtGroupSpiroStreamData, session->common.sGhsTime.epoch);
            updateDataHeaderRefs(&msmtGroupSpiroStreamData, sub_session_id, 0);
            updateDataRtsa(&msmtGroupSpiroStreamData, flow_index, &flowBytes[NO_OF_SAMPLES * SAMPLE_SIZE], NO_OF_SAMPLES * SAMPLE_SIZE, msmt_id++);
        }
        else if (spiro_sequence == 5)
        {
            if (!prepareMeasurements(msmtGroupSpiroManeuvData, 0)) return false;
            NRF_LOG_DEBUG("Sending Spirometer Maneuver data");
            updateTimeStampEpoch(&msmtGroupSpiroManeuvData, session->common.sGhsTime.epoch);
            updateDataHeaderRefs(&msmtGroupSpiroManeuvData, sub_session_id, 0);
            s_MderFloat mder;
            mder.exponent = -3;
            mder.mantissa = fev1Val;
            mder.mderFloatType = MDER_FLOAT;
            mder.specialValue = MDER_NUMBER;
            fev1_ids[fev1_id_index] = msmt_id;
            updateDataNumeric(&msmtGroupSpiroManeuvData, fev1_index, &mder, msmt_id++);
            mder.mantissa = fev6Val;
            updateDataNumeric(&msmtGroupSpiroManeuvData, fev6_index, &mder, msmt_id++);
            mder.mantissa = fvcVal;
            fvc_ids[fvc_id_index] = msmt_id;
            updateDataNumeric(&msmtGroupSpiroManeuvData, fvc_index, &mder, msmt_id++);
            mder.mantissa = pefVal;
            updateDataNumeric(&msmtGroupSpiroManeuvData, pef_index, &mder, msmt_id++);
            mder.mantissa = fetVal;
            updateDataNumeric(&msmtGroupSpiroManeuvData, fet_index, &mder, msmt_id++);
            mder.mantissa = fev1z_val;
            updateDataNumeric(&msmtGroupSpiroManeuvData, fev1z_index, &mder, msmt_id++);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1z_index, fev1_ids[fev1_id_index], 0);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1z_index, settings_id[0], 1);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1z_index, settings_id[1], 2);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1z_index, settings_id[2], 3);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1z_index, settings_id[3], 4);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1z_index, settings_id[4], 5);
            mder.mantissa = fev1_lln_val;
            updateDataNumeric(&msmtGroupSpiroManeuvData, fev1_lln_index, &mder, msmt_id++);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1_lln_index, settings_id[0], 0);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1_lln_index, settings_id[1], 1);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1_lln_index, settings_id[2], 2);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1_lln_index, settings_id[3], 3);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1_lln_index, settings_id[4], 4);
            mder.mantissa = fev1_percent_pred_val;
            mder.exponent = -1;
            updateDataNumeric(&msmtGroupSpiroManeuvData, fev1_percent_pred_index, &mder, msmt_id++);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1_percent_pred_index, fev1_ids[fev1_id_index], 0);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1_percent_pred_index, settings_id[0], 1);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1_percent_pred_index, settings_id[1], 2);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1_percent_pred_index, settings_id[2], 3);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1_percent_pred_index, settings_id[3], 4);
            updateDataGhsMsmtRefs(&msmtGroupSpiroManeuvData, fev1_percent_pred_index, settings_id[4], 5);
            fev1_id_index++;
            fvc_id_index++;
        }
        else if (spiro_sequence == 6)
        {
            if (!prepareMeasurements(msmtGroupSpiroSubSessionData, 0)) return false;
            NRF_LOG_DEBUG("Sending first maneuver Spirometer sub session End");
            updateDataHeaderRefs(&msmtGroupSpiroSubSessionData, sub_session_id, 0);
            updateTimeStampEpoch(&msmtGroupSpiroSubSessionData, session->common.sGhsTime.epoch);
            updateDataCoded(&msmtGroupSpiroSubSessionData, sub_session_index, MDC_END, msmt_id++);
        }
        else if (spiro_sequence == 7)
        {
            if (!prepareMeasurements(msmtGroupSpiroSummaryData, 0)) return false;
            NRF_LOG_DEBUG("Sending Spirometer summary data");
            updateTimeStampEpoch(&msmtGroupSpiroSummaryData, session->common.sGhsTime.epoch);
            updateDataHeaderRefs(&msmtGroupSpiroSummaryData, session_id, 0);
            updateDataCoded(&msmtGroupSpiroSummaryData, fvcAtsGrade_index, fvcAtsGradeVal, msmt_id++);
            updateDataCoded(&msmtGroupSpiroSummaryData, fev1AtsGrade_index, fev1AtsGradeVal, msmt_id++);
            updateDataGhsMsmtRefs(&msmtGroupSpiroSummaryData, fvcAtsGrade_index, fvc_ids[0], 0);
            updateDataGhsMsmtRefs(&msmtGroupSpiroSummaryData, fvcAtsGrade_index, fev1_ids[0], 1);
            updateDataGhsMsmtRefs(&msmtGroupSpiroSummaryData, fev1AtsGrade_index, fev1_ids[0], 0);
            updateDataGhsMsmtRefs(&msmtGroupSpiroSummaryData, fev1AtsGrade_index, fvc_ids[0], 1);
        }
        if (spiro_sequence == 8)
        {
            if (!prepareMeasurements(msmtGroupSpiroSessionEndData, 0)) return false;
            // Add the command
            NRF_LOG_DEBUG("Sending Spirometer session end");
            updateDataHeaderRefs(&msmtGroupSpiroSessionEndData, session_id, 0);
            updateTimeStampEpoch(&msmtGroupSpiroSessionEndData, session->common.sGhsTime.epoch);
            updateDataCoded(&msmtGroupSpiroSessionEndData, session_end_index, MDC_END, msmt_id++);
        }
        if (spiro_sequence == 9)
        {
            ble_disconnected_handler(NULL);
            spiro_sequence = 0;
            return true;
        }
        spiro_sequence++;
    #endif
    #if (THERMOMETER == 1)
        if (!prepareMeasurements(msmtGroupTempData, msmt->common.recordNumber)) return false;
        s_MderFloat mder;
        mder.mderFloatType = MDER_FLOAT;
        mder.specialValue = MDER_NUMBER;
        mder.exponent = -2;
        mder.mantissa = msmt->temp;
        updateDataNumeric(&msmtGroupTempData, temp_index, &mder, msmt_id++);
        mder.exponent = -2;
        mder.mantissa = msmt->ambient;
        updateDataNumeric(&msmtGroupTempData, ambient_index, &mder, msmt_id++);
        updateTimeStampEpoch(&msmtGroupTempData, msmt->common.sGhsTime.epoch);
        NRF_LOG_DEBUG("Temperature msmt to send");
    #endif  // Ear thermometer
    #if (SCALE == 1)
        if (scale_sequence > 0)
        {
            if (!prepareMeasurements(msmtGroupScaleData, msmt->common.recordNumber)) return false;
            s_MderFloat mder;
            mder.mderFloatType = MDER_FLOAT;
            mder.specialValue = MDER_NUMBER;
            mder.exponent = -2;
            mder.mantissa = msmt->mass;
            updateDataGhsMsmtRefs(&msmtGroupScaleData, bmi_index, msmt_id, 0);      // Add the references, this is the body mass
            updateDataGhsMsmtRefs(&msmtGroupScaleData, bmi_index, height_ref, 1);   // and this is the height
            updateDataNumeric(&msmtGroupScaleData, mass_index, &mder, msmt_id++);
            unsigned long bmi = (unsigned long)msmt->mass;
            unsigned long div = HEIGHT * HEIGHT / 100;
            bmi = (bmi) * 10000 /div; // kg/m*m    mass * 100 *100 / (mm * mm )
            mder.mantissa = bmi;
            updateDataNumeric(&msmtGroupScaleData, bmi_index, &mder, msmt_id);  // Not using msmt_id - don't increment
            updateTimeStampEpoch(&msmtGroupScaleData, msmt->common.sGhsTime.epoch);
            NRF_LOG_DEBUG("Weight msmt to send with mass %lu div %lu bmi %lu", msmt->mass, div, bmi);
        }
        else
        {
            if (!prepareMeasurements(settingsGroupData, msmt->common.recordNumber)) return false;
            // Add the command
           // settingsGroupData->data[0] = (global_send.current_command & 0xFF);
           // settingsGroupData->data[1] = ((global_send.current_command >> 8) & 0xFF);
            NRF_LOG_DEBUG("Weight Scale Height settings msmt to send");
            scale_sequence++;
        }
    #endif
    return true;
}

/**
 * This method generates fake data on the push of button 4 on the DK and stores it. There is no
 * stored data option for the Spirometer...it's too hard to generate fake spirometer data that is
 * even close to realistic, especially the waveforms.
 *
 * The fake data are generated from the current time stamp. This method would be replaced with
 * data coming from the sensor MCU interrupt while not connected.
 */
#if (USES_STORED_DATA == 1)
bool generateAndAddStoredMsmt(unsigned long long timeStampMsmt, unsigned long timeStamp, unsigned short numberOfStoredMsmtGroups)
{
    #if (BP_CUFF == 1)
                char buffer[512];
                memset(buffer, 0, 512);
        storedMsmts[numberOfStoredMsmtGroups].hasTimeStamp = true;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.epoch = epoch + timeStampMsmt;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.clockType = sMetTime->clockType;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.clockResolution = sMetTime->clockResolution;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.offsetShift = sMetTime->offsetShift;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.timeSync = sMetTime->timeSync;
        storedMsmts[numberOfStoredMsmtGroups].systolic = 95 + (timeStamp & 0x0F);
        storedMsmts[numberOfStoredMsmtGroups].diastolic = 55 + (timeStamp & 0x0F);
        storedMsmts[numberOfStoredMsmtGroups].mean = 
            (storedMsmts[numberOfStoredMsmtGroups].systolic +
             storedMsmts[numberOfStoredMsmtGroups].diastolic) / 2;
        storedMsmts[numberOfStoredMsmtGroups].pulseRate = 40 + (timeStamp & 0x07);
        unsigned short stat = ((timeStamp & 0x1FB) << 7);
        storedMsmts[numberOfStoredMsmtGroups].hasStatus = ((storedMsmts[numberOfStoredMsmtGroups].systolic & 0x01) == 0x01);
        storedMsmts[numberOfStoredMsmtGroups].status_cuff_too_loose = (stat & BP_STATUS_CUFF_TOO_LOOSE);
        storedMsmts[numberOfStoredMsmtGroups].status_improper_position = (stat & BP_STATUS_IMPROPER_POSITION);
        storedMsmts[numberOfStoredMsmtGroups].status_irregular_pulse = (stat & BP_STATUS_IRREGULAR_PULSE);
        storedMsmts[numberOfStoredMsmtGroups].status_movement = (stat & BP_STATUS_MOVEMENT);
        NRF_LOG_INFO("Measurement added: sys %u, dia %u, mean %u, PR %u, timestamp %llu", 
                storedMsmts[numberOfStoredMsmtGroups].systolic,
                storedMsmts[numberOfStoredMsmtGroups].diastolic,
                storedMsmts[numberOfStoredMsmtGroups].mean,
                storedMsmts[numberOfStoredMsmtGroups].pulseRate, 
                storedMsmts[numberOfStoredMsmtGroups].sMetTime.epoch);
        return true;
    #endif
    #if (PULSE_OX == 1)
        storedMsmts[numberOfStoredMsmtGroups].hasTimeStamp = true;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.epoch = epoch + timeStampMsmt;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.clockType = sMetTime->clockType;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.clockResolution = sMetTime->clockResolution;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.offsetShift = sMetTime->offsetShift;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.timeSync = sMetTime->timeSync;

        storedMsmts[numberOfStoredMsmtGroups].spo2 = 95 + (timeStamp & 0x03);
        storedMsmts[numberOfStoredMsmtGroups].pulseRate = 45 + (timeStamp & 0x07);
        storedMsmts[numberOfStoredMsmtGroups].pulseQuality = 523 + (timeStamp & 0xFF);

        NRF_LOG_INFO("Measurement added: SpO2 %u%, PR %u, Pulsatile X 100 %u%, timestamp %lu", 
            storedMsmts[numberOfStoredMsmtGroups].spo2, 
            storedMsmts[numberOfStoredMsmtGroups].pulseRate,
        return true;
    #endif
    #if (GLUCOSE == 1)

        storedMsmts[numberOfStoredMsmtGroups].hasTimeStamp = true;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.epoch = epoch + timeStampMsmt;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.clockType = sMetTime->clockType;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.clockResolution = sMetTime->clockResolution;        storedMsmts[numberOfStoredMsmtGroups].sMetTime.offsetShift = sMetTime->offsetShift;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.timeSync = sMetTime->timeSync;
        storedMsmts[numberOfStoredMsmtGroups].conc = (95 + (timeStamp & 0x1F)) * 10;
        storedMsmts[numberOfStoredMsmtGroups].body_site = MDC_CTXT_GLU_SAMPLELOCATION_FINGER + (timeStamp & 0x03) * 4;
        storedMsmts[numberOfStoredMsmtGroups].meal_context = MDC_CTXT_GLU_MEAL_PREPRANDIAL + (timeStamp & 0x03) * 4;
        storedMsmts[numberOfStoredMsmtGroups].health = MDC_CTXT_GLU_HEALTH_MINOR + (timeStamp & 0x03) * 4;
        storedMsmts[numberOfStoredMsmtGroups].tester = MDC_CTXT_GLU_TESTER_SELF + (timeStamp & 0x04);
        storedMsmts[numberOfStoredMsmtGroups].carbs = 150 + (timeStamp & 0x7F);
        storedMsmts[numberOfStoredMsmtGroups].carbs_type = MDC_CTXT_GLU_CARB_BREAKFAST + (timeStamp & 0x03) * 4;
        storedMsmts[numberOfStoredMsmtGroups].meds = 100 + (timeStamp & 0x0F); // IU times 10
        storedMsmts[numberOfStoredMsmtGroups].medication_type = MDC_CTXT_MEDICATION_RAPIDACTING + (timeStamp & 0x03) * 4;
        storedMsmts[numberOfStoredMsmtGroups].exer = 60 + (timeStamp & 0x1F);
        NRF_LOG_INFO("Measurement added: conc %u, carbs %u, meds %u, exer %u, timestamp %lu", 
                storedMsmts[numberOfStoredMsmtGroups].conc,
                storedMsmts[numberOfStoredMsmtGroups].carbs,
                storedMsmts[numberOfStoredMsmtGroups].meds,
                storedMsmts[numberOfStoredMsmtGroups].exer, 
                timeStamp);
        return true;
    #endif
   #if (SCALE == 1)
        storedMsmts[numberOfStoredMsmtGroups].hasTimeStamp = true;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.epoch = epoch + timeStampMsmt;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.clockType = sMetTime->clockType;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.clockResolution = sMetTime->clockResolution;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.offsetShift = sMetTime->offsetShift;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.timeSync = sMetTime->timeSync;
        storedMsmts[numberOfStoredMsmtGroups].mass = 6800 + (timeStamp & 0xFF);

        NRF_LOG_INFO("Measurement added: Weight %u%, timestamp %lu", 
            storedMsmts[numberOfStoredMsmtGroups].mass, timeStamp);
        return true;
    #endif
    #if (THERMOMETER == 1)
        storedMsmts[numberOfStoredMsmtGroups].hasTimeStamp = true;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.epoch = epoch + timeStampMsmt;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.clockType = sMetTime->clockType;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.clockResolution = sMetTime->clockResolution;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.offsetShift = sMetTime->offsetShift;
        storedMsmts[numberOfStoredMsmtGroups].sMetTime.timeSync = sMetTime->timeSync;
        storedMsmts[numberOfStoredMsmtGroups].temp = 9800 + (timeStamp & 0xFF);
        storedMsmts[numberOfStoredMsmtGroups].ambient = 7200 + (timeStamp & 0x1FF);

        NRF_LOG_INFO("Measurement added: Temperature %u%, ambient temperature %u, timestamp %lu", 
            storedMsmts[numberOfStoredMsmtGroups].temp, storedMsmts[numberOfStoredMsmtGroups].ambient, timeStamp);
        return true;
    #endif
    return false;
    // No stored data generated for Spirometer
}

// It is assumed this method is called only if the operation is supported.
unsigned short getNumberOfStoredRecords(unsigned char* cmd, unsigned short len)
{
    if (numberOfStoredMsmtGroups == 0)
    {
        return numberOfStoredMsmtGroups;
    }
    s_MsmtCommon *common = &storedMsmts[0].common;
    switch(cmd[1])
    {
        case RACP_ALL:
            return numberOfStoredMsmtGroups;
        
        case RACP_GTE:
        {
            if (cmd[2] == RACP_RECORD_NUM && len >= 7)
            {
                unsigned long recordNumber = (unsigned long)cmd[3] + ((unsigned long)cmd[4] << 8)
                    + ((unsigned long)cmd[5] << 16) + ((unsigned long)cmd[6] << 24);
                if (recordNumber < common->recordNumber)
                {
                    return numberOfStoredMsmtGroups;
                }
                else if (recordNumber > storedMsmts[numberOfStoredMsmtGroups - 1].common.recordNumber)
                {
                    return 0;
                }
                return numberOfStoredMsmtGroups - (recordNumber - common->recordNumber);
            }      
            if (cmd[2] == RACP_TIMESTAMP && len >= 9)
            {
                unsigned long long epoch = getEpochFromBytes(&cmd[3]);  // Should check for length
                unsigned short i;
                if (epoch < common->sGhsTime.epoch)
                {
                    return numberOfStoredMsmtGroups;
                }
                else if (epoch > storedMsmts[numberOfStoredMsmtGroups - 1].common.sGhsTime.epoch)
                {
                    return 0;
                }
                for (i = 0; i < numberOfStoredMsmtGroups; i++)
                {
                    if (epoch < storedMsmts[i].common.sGhsTime.epoch)
                    {
                        return numberOfStoredMsmtGroups - i;
                    }
                }
                return 0;
            }
            return 0;
        }
        
        case RACP_FIRST:
        case RACP_LAST:
            return 1;
        
        default:
            return 0;
    }
}

// Return index. -1 indicates no records found
long getStartIndexInStoredRecords(unsigned char* cmd, unsigned short len)
{
    if (numberOfStoredMsmtGroups == 0)
    {
        return -1;
    }
    s_MsmtCommon *common = &storedMsmts[0].common;
    switch(cmd[1])
    {
        case RACP_ALL:
            return 0;
        
        case RACP_GTE:
        {
            if (cmd[2] == RACP_RECORD_NUM && len >= 7)
            {
                unsigned long recordNumber = (unsigned long)cmd[3] + ((unsigned long)cmd[4] << 8)
                    + ((unsigned long)cmd[5] << 16) + ((unsigned long)cmd[6] << 24);
                if (recordNumber < common->recordNumber)
                {
                    return 0;
                }
                else if (recordNumber > storedMsmts[numberOfStoredMsmtGroups - 1].common.recordNumber)
                {
                    return -1;
                }
                return (recordNumber - common->recordNumber);
            }

            if (cmd[2] == RACP_TIMESTAMP && len >= 9)
            {
                unsigned long long epoch = getEpochFromBytes(&cmd[2]);  // Should check for length
                unsigned short i;
                if (epoch <= common->sGhsTime.epoch)
                {
                    return 0;
                }
                else if (epoch > storedMsmts[numberOfStoredMsmtGroups - 1].common.sGhsTime.epoch)
                {
                    return -1;
                }
                for (i = 0; i < numberOfStoredMsmtGroups; i++)
                {
                    if (epoch < storedMsmts[i].common.sGhsTime.epoch)
                    {
                        return i;
                    }
                }
                return 0;
            }
            return -1;
        }
        
        case RACP_FIRST:
            return 0;
        
        case RACP_LAST:
            return numberOfStoredMsmtGroups - 1;
        
        default:
            return -1;
    }
}

/**
 * This method queues the stored measurement to be sent. In the main loop, the queue is read
 * and if not busy sending data, the send_flag is set and the measurement de-queued.
 */
void sendStoredSpecializationMsmts(unsigned short stored_count)
{
    // Set up parameters for notification of this PDU - likely in fragments
    #if (BP_CUFF == 1)
        NRF_LOG_DEBUG("Stored Measurements added to queue: sys %u, dia %u, mean %u, PR %u, count %d", 
            storedMsmts[stored_count].systolic,
            storedMsmts[stored_count].diastolic,
            storedMsmts[stored_count].mean,
            storedMsmts[stored_count].pulseRate,
            stored_count);
        if(sd_mutex_acquire(&q_mutex) != NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN)
        {
            enqueue(queue, &storedMsmts[stored_count], sizeof(s_MsmtData));
            sd_mutex_release(&q_mutex);
        }
    #endif
    #if (PULSE_OX == 1)
        NRF_LOG_DEBUG("Stored Measurements added to queue: spo2 %u, pr %u, qual %u, count %d", 
            storedMsmts[stored_count].spo2,
            storedMsmts[stored_count].pulseRate,
            storedMsmts[stored_count].pulseQuality,
            stored_count);
        if(sd_mutex_acquire(&q_mutex) != NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN)
        {
            enqueue(queue, &storedMsmts[stored_count], sizeof(s_MsmtData));
            sd_mutex_release(&q_mutex);
        }
    #endif
    #if (GLUCOSE == 1)
        NRF_LOG_DEBUG("Stored Measurements added to queue: conc %u, carbs %u, meds %u, exer %u, count %d", 
            storedMsmts[stored_count].conc,
            storedMsmts[stored_count].carbs,
            storedMsmts[stored_count].meds,
            storedMsmts[stored_count].exer,
            stored_count);
        if(sd_mutex_acquire(&q_mutex) != NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN)
        {
            enqueue(queue, &storedMsmts[stored_count], sizeof(s_MsmtData));
            sd_mutex_release(&q_mutex);
        }
    #endif
    #if (SCALE == 1)
        NRF_LOG_DEBUG("Stored Measurements added to queue: mass %u, count %d", 
            storedMsmts[stored_count].mass, stored_count);
        if(sd_mutex_acquire(&q_mutex) != NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN)
        {
            if (scale_sequence == 0)
            {
                enqueue(queue, &storedMsmts[stored_count], sizeof(s_MsmtData)); // This is to trigger the setting
            }
            enqueue(queue, &storedMsmts[stored_count], sizeof(s_MsmtData));
            sd_mutex_release(&q_mutex);
        }
    #endif
    #if (THERMOMETER == 1)
        NRF_LOG_DEBUG("Stored Measurements added to queue: temp %u, count %d", 
            storedMsmts[stored_count].temp, stored_count);
        if(sd_mutex_acquire(&q_mutex) != NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN)
        {
            enqueue(queue, &storedMsmts[stored_count], sizeof(s_MsmtData));
            sd_mutex_release(&q_mutex);
        }
    #endif
}

/**
 * Deletes all the stored data. Called when the PHG sends delete stored data command
 */
void deleteStoredSpecializationMsmts(void)
{
    memset(&storedMsmts, 0, NUMBER_OF_STORED_MSMTS * sizeof(s_MsmtData));
}
#endif

/**
 * This method generates fake 'live' data. The method is signaled periodically with a timer. The
 * current time stamp is used to generate the fake data. The fake data is stored in the respective
 * structs for the specialization. After this method is called the specialization struct is placed
 * in the queue and then dequeued in the main loop. At that point the struct is passed to the 
 * encoder which populates the data array which is then sent.
 *
 * The timer is set to trigger at a rapid rate so this method is skipped if the previous data has
 * not yet been sent. 
 *
 * No live data is generated for the Glucose meter and the Spirometer. The Spirometer data has a 
 * complex relation to one another so it is all preloaded and thus every run of the spirometer gives
 * exactly the same results (except for the time stamp).
 *
 * This method exists as we have no sensor to feed us real data. This method would be replaced by sensor
 * data coming from an MCU via an interrupt or event while connected.
 */
 #if (USES_LIVE_DATA == 1)
void generateLiveDataForSpecializations(unsigned long live_data_count, unsigned long long timeStampMsmt, unsigned long timeStamp)
{
    #if (BP_CUFF == 1)
        #define LIVE_COUNT_MAX 64
        if ((live_data_count & 0x07) == 0x00)
        {
            s_MsmtData bpMsmt;
            unsigned short rand = (timeStamp / 7);
            memset(&bpMsmt, 0, sizeof(s_MsmtData));

            bpMsmt.systolic = 100 + (rand & 0x0F);
            bpMsmt.diastolic = 55 + (rand & 0x0F);
            bpMsmt.mean = ((bpMsmt.systolic + bpMsmt.diastolic) >> 1);
            bpMsmt.hasStatus = ((bpMsmt.mean & 0x01) == 0x01);
            bpMsmt.pulseRate = 40 + (rand & 0x07);
            bpMsmt.common.hasTimeStamp = true;
            bpMsmt.common.sGhsTime.epoch = epoch + timeStampMsmt;
            bpMsmt.common.sGhsTime.flagKnownTimeline = GHS_TIME_FLAG_ON_CURRENT_TIMELINE;
            bpMsmt.common.sGhsTime.offsetShift = sGhsTime->offsetShift;
            bpMsmt.common.sGhsTime.timeSync = sGhsTime->timeSync;
            unsigned short stat = (timeStamp & 0x3F);
            bpMsmt.status_cuff_too_loose = (stat & BP_STATUS_CUFF_TOO_LOOSE);
            bpMsmt.status_improper_position = (stat & BP_STATUS_IMPROPER_POSITION);
            bpMsmt.status_irregular_pulse = (stat & BP_STATUS_IRREGULAR_PULSE);
            bpMsmt.status_movement = (stat & BP_STATUS_MOVEMENT);
            if (bpMsmt.hasStatus)
            {
                updateDataRestoreLastMsmt(&msmtGroupBpData);
            }
            else
            {
                updateDataDropLastMsmt(&msmtGroupBpData);
            }
            //reportStatus = !reportStatus;

            NRF_LOG_INFO("Measurement added to queue: sys %u, dia %u, mean %u, PR %u, status: %u", 
                bpMsmt.systolic,
                bpMsmt.diastolic,
                bpMsmt.mean,
                bpMsmt.pulseRate,
                bpMsmt.hasStatus);
            if(sd_mutex_acquire(&q_mutex) != NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN)
            {
                enqueue(queue, &bpMsmt, sizeof(s_MsmtData));
                sd_mutex_release(&q_mutex);
            }
        }
        else
        {
            return;
        }
    #endif
    
    #if (PULSE_OX == 1)
        s_MsmtData poMsmt;
        memset(&poMsmt, 0, sizeof(s_MsmtData));
        poMsmt.spo2 = 95 + (timeStamp & 0x03);
        poMsmt.pulseRate = 45 + (timeStamp & 0x07);
        poMsmt.pulseQuality = 523 + (timeStamp & 0xFF);
        if ((live_data_count & 0x0F) == 0x00)
        {
            poMsmt.common.hasTimeStamp = true;
            poMsmt.common.sGhsTime.epoch = epoch + timeStampMsmt;
            poMsmt.common.sGhsTime.offsetShift = sGhsTime->offsetShift;
            poMsmt.common.sGhsTime.timeSync = sGhsTime->timeSync;
            poMsmt.common.sGhsTime.flagKnownTimeline = GHS_TIME_FLAG_ON_CURRENT_TIMELINE;
            NRF_LOG_INFO("Measurement added to queue: spo2 %u, pulse rate %u, pulse quality %u", 
                poMsmt.spo2,
                poMsmt.pulseRate,
                poMsmt.pulseQuality);
            poMsmt.isContinuous = false;
        }
        else
        {
            poMsmt.common.hasTimeStamp = false;
            poMsmt.isContinuous = true;
        }
        if(sd_mutex_acquire(&q_mutex) != NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN)
        {
            enqueue(queue, &poMsmt, sizeof(s_MsmtData));
            sd_mutex_release(&q_mutex);
        }
    #endif
    #if (HEART_RATE == 1)
        s_MsmtData hrMsmt;
        hrMsmt.heartRate = 55 + ((timeStamp >> 9) & 0x07);
        if(sd_mutex_acquire(&q_mutex) != NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN)
        {
            enqueue(queue, &hrMsmt, sizeof(s_MsmtData));
            sd_mutex_release(&q_mutex);
        }
    #endif
    #if (SPIROMETER == 1)
        if (spiro_sequence >= 10) return;
        s_MsmtData session;  // Dummy - data is already encoded
        memset(&session, 0, sizeof(s_MsmtData));
        session.common.sGhsTime.epoch = epoch + timeStampMsmt;
        session.common.sGhsTime.offsetShift = sGhsTime->offsetShift;
        session.common.sGhsTime.timeSync = sGhsTime->timeSync;
        if(sd_mutex_acquire(&q_mutex) != NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN)
        {
            enqueue(queue, &session, sizeof(s_MsmtData));
            sd_mutex_release(&q_mutex);
        }
    #endif
    #if (SCALE == 1)
        s_MsmtData scaleMsmt;
        memset(&scaleMsmt, 0, sizeof(s_MsmtData));
        scaleMsmt.mass = 6800 + (timeStamp & 0xFF);
        scaleMsmt.common.hasTimeStamp = true;
        scaleMsmt.common.sGhsTime.epoch = epoch + timeStampMsmt;
        scaleMsmt.common.sGhsTime.flagKnownTimeline = GHS_TIME_FLAG_ON_CURRENT_TIMELINE;
        scaleMsmt.common.sGhsTime.offsetShift = sGhsTime->offsetShift;
        scaleMsmt.common.sGhsTime.timeSync = sGhsTime->timeSync;
        NRF_LOG_INFO("Measurement added to queue: weight %u", scaleMsmt.mass);
        if(sd_mutex_acquire(&q_mutex) != NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN)
        {
            if (scale_sequence == 0)
            {
                enqueue(queue, &scaleMsmt, sizeof(s_MsmtData)); // This is to trigger the setting
            }
            enqueue(queue, &scaleMsmt, sizeof(s_MsmtData)); // This is the live measurement
            sd_mutex_release(&q_mutex);
        }
    #endif
    #if (THERMOMETER == 1)
        s_MsmtData tempMsmt;
        memset(&tempMsmt, 0, sizeof(s_MsmtData));
        tempMsmt.temp = 9800 + (timeStamp & 0xFF);
        tempMsmt.ambient = 7200 + (timeStamp & 0x1FF);
        tempMsmt.common.hasTimeStamp = true;
        tempMsmt.common.sGhsTime.epoch = epoch + timeStampMsmt;
        tempMsmt.common.sGhsTime.offsetShift = sGhsTime->offsetShift;
        tempMsmt.common.sGhsTime.flagKnownTimeline = GHS_TIME_FLAG_ON_CURRENT_TIMELINE;
        tempMsmt.common.sGhsTime.timeSync = sGhsTime->timeSync;
        NRF_LOG_INFO("Measurement added to queue: body temp %u ambient temp %u", tempMsmt.temp, tempMsmt.ambient);
        if(sd_mutex_acquire(&q_mutex) != NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN)
        {
            enqueue(queue, &tempMsmt, sizeof(s_MsmtData));
            sd_mutex_release(&q_mutex);
        }
    #endif
    // No live data for glucose meter
}
#endif
/**
 * This method os called when the device receives a set time command
 */
void handleSpecializationsOnSetTime(unsigned short numberOfStoredMsmtGroups, long long diff, unsigned short timeSync)
{
    int i;
    unsigned long long udiff = -diff;
    #if (BP_CUFF == 1)
        updateTimeStampTimeSync(&msmtGroupBpData, timeSync);    // When the device receives a set time in the set time is the
                                                                // synchronization method of the PHG. We update the sync part
                                                                // of the time stamp in the data array, as this will not change
                                                                // The actual time stamp will come from the measurement.
    #endif
    #if (PULSE_OX == 1)
        updateTimeStampTimeSync(&msmtGroupSpotData, timeSync);
    #endif
    #if (SPIROMETER == 1)
        updateTimeStampTimeSync(&msmtGroupSpiroSessionEndData, timeSync);
        updateTimeStampTimeSync(&msmtGroupSpiroStreamData, timeSync);
        updateTimeStampTimeSync(&msmtGroupSpiroManeuvData, timeSync);
        updateTimeStampTimeSync(&msmtGroupSpiroSessionData, timeSync);
        updateTimeStampTimeSync(&msmtGroupSpiroSummaryData, timeSync);
        updateTimeStampTimeSync(&msmtGroupSpiroSubSessionData, timeSync);
    #endif
    #if (SCALE == 1)
        updateTimeStampTimeSync(&msmtGroupScaleData, timeSync);
    #endif
    #if (THERMOMETER == 1)
        updateTimeStampTimeSync(&msmtGroupTempData, timeSync);
    #endif
    // If we have stored data and the time has been set, the timeline has been changed. Here
    // we adjust the time stamps of all our stored data to the new timeline. THat will
    // involve updating the epoch field of the stored time stamp by the difference and
    // and changing the time sync to that specified in the set time.
    #if (USES_STORED_DATA == 1)
        for (i = 0; i < numberOfStoredMsmtGroups; i++)
        {
             if (storedMsmts[i].common.sGhsTime.flagKnownTimeline == GHS_TIME_FLAG_ON_CURRENT_TIMELINE)
             {
                 storedMsmts[i].common.sGhsTime.epoch = (diff < 0) ? storedMsmts[i].common.sGhsTime.epoch - udiff
                            : storedMsmts[i].common.sGhsTime.epoch + diff;
                 storedMsmts[i].common.sGhsTime.timeSync = timeSync;
             }
        }
    #endif
}

void setNotOnCurrentTimeline(unsigned long long newCount)
{
    int i;
    #if (USES_STORED_DATA == 1)
        for (i = 0; i < numberOfStoredMsmtGroups; i ++)
        {
            storedMsmts[i].sMetTime.flagUnknownTimeline = MET_TIME_FLAG_UNKNOWN_TIMELINE;
        }
    #endif
}

/**
 * This method frees all the resources taken when we generated the data array structs. This method
 * is called when the device disconnects.
 */
void cleanUpSpecializations(void)
{
    #if (BP_CUFF == 1)
        cleanUpMsmtGroupData(&msmtGroupBpData);
    #endif

    #if (PULSE_OX == 1)
        cleanUpMsmtGroupData(&msmtGroupSpotData);
        cleanUpMsmtGroupData(&msmtGroupContData);
        cleanUpMsmtGroupData(&msmtGroupOptimizedContData);
    #endif
    #if (GLUCOSE == 1)
        cleanUpMsmtGroupData(&msmtGroupGlucData);
    #endif
    #if (HEART_RATE == 1)
        cleanUpMsmtGroupData(&msmtGroupHrData);
    #endif
    #if (SPIROMETER == 1)
        cleanUpMsmtGroupData(&msmtGroupSpiroSessionEndData);
        cleanUpMsmtGroupData(&msmtGroupSpiroSummaryData);
        cleanUpMsmtGroupData(&msmtGroupSpiroManeuvData);
        cleanUpMsmtGroupData(&msmtGroupSpiroStreamData);
        cleanUpMsmtGroupData(&msmtGroupSpiroSubSessionData);
        cleanUpMsmtGroupData(&msmtGroupSpiroSettingsData);
        cleanUpMsmtGroupData(&msmtGroupSpiroSessionData);
    #endif
    #if (SCALE == 1)
        cleanUpMsmtGroupData(&msmtGroupScaleData);
        cleanUpMsmtGroupData(&settingsGroupData);
    #endif
    #if (THERMOMETER == 1)
        cleanUpMsmtGroupData(&msmtGroupTempData);
    #endif
    #if (USES_TIMESTAMP == 1)
        cleanUpGhsTime(&sGhsTime);
        cleanUpTimeInfoData(&sTimeInfoData);
        cleanUpTimeInfo(&sTimeInfo);
    #endif
}
